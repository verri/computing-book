[["index.html", "Computando Uma abordagem prática a programação, algoritmos e estruturas de dados Prefácio", " Computando Uma abordagem prática a programação, algoritmos e estruturas de dados Filipe A. N. Verri Lourenço A. Pereira Jr. 2022-12-02 Prefácio Já se perguntou o que, de fato, é Computação? Como ela está relacionada com a Informática? E com os computadores digitais? Estes conceitos são fortemente ligados, mas, de maneira alguma, são as mesmas coisas. Neste livro, pretendo, de uma maneira prática, expor estes conceitos e prepará-lo para o universo da programação independente da sua área de atuação. Espero que futuros engenheiros, cientistas da computação, cientistas de dados, biólogos, químicos, matemáticos e outros graduandos se beneficiem desse material. Veja que este não é um curso de programação numa linguagem específica, nem mesmo um curso de introdução às Ciências de Computação (o que julgo muito mais abrangente do que o escopo deste livro). No entanto, meu intuito é habilitá-los a resolver problemas computacionais de maneira organizada e efetiva, independentemente da linguagem de programação ou área de domínio. Inclusive, este não é um livro que tem como objetivo ensinar todos os aspectos de determinada linguagem de programação. Na medida do possível, os leitores serão direcionados a materiais específicos a esta ou aquela linguagem de programação. Apresentarei os principais algoritmos e estruturas de dados utilizados na atualidade – consequentemente sou forçado a deixar de fora tópicos históricos ou muito avançados. É altamente recomendado que o leitor tenha familiaridade com símbolos e notações matemáticas. A sequência dos tópicos e a profundidade de cada um deles é fortemente baseada na minha experiência nas disciplinas básicas de programação do Instituto Tecnológico de Aeronáutica, e devem funcionar muito bem para qualquer outro curso de engenharia. No entanto, peço encarecidamente que não utilizem esse material desatualizado – nada pior para os alunos do que aprender arcaísmos. Esta é uma área que está em constante evolução e assuntos desatualizados podem prejudicar significantemente os alunos que formamos. — Filipe Verri "],["sobre-os-autores.html", "Sobre os autores", " Sobre os autores Filipe Verri Lourenço Pereira Jr. "],["agradecimentos.html", "Agradecimentos", " Agradecimentos Agradeço ao Prof. Johnny Marques por disponibilizar seu material didático para o preparo do Capítulo sobre Complexidade Computacional e vários capítulos da Parte III Estruturas de Dados. "],["guia-ita.html", "Guia ITA", " Guia ITA Este livro é utilizado como bibliografia complementar nas disciplinas CES-10 e CES-11 do ITA. Para facilitar o acompanhamento destas disciplinas, disponibilizamos um guia conectando os tópicos da ementa com os capítulos deste livro. CES-10 – Introdução à Computação Ementa Capítulos Conceitos primários: computador, algoritmo, programa, linguagem de programação, compilador. Capítulo 1 Software básico para computadores. Capítulo 2 Comandos de uma linguagem procedimental: atribuição, entrada e saída, condicionais, repetitivos e seletivos. Tratamento de exceções. Capítulos 3 e 4 Tipos escalares e estruturados. Capítulos 2 e 6 Subprogramação: funções, passagem de parâmetros por valor e por referência, escopo de variáveis, e recursividade. Capítulo 5 Ponteiros. Capítulo 7 CES-11 – Algoritmos e Estruturas de Dados I Ementa Capítulos Tópicos em recursividade. Noções de complexidade de algoritmos. Vetores e encadeamento de estruturas. Pilhas, filas e deques. Árvores gerais e binárias. Grafos orientados e não orientados. Algoritmos básicos para grafos. Filas de prioridade. Métodos básicos de ordenação. Noções de programação orientada a objetos. "],["preliminares.html", "1 Preliminares 1.1 Motivação 1.2 Definições 1.3 Considerações finais", " 1 Preliminares Neste capítulo, motivaremos a importância da computação e definiremos os principais termos e conceitos a serem abordados nos próximos capítulos. 1.1 Motivação Imagine instruir uma pessoa a calcular juros compostos. Dado que conhecemos o montante inicial \\(x\\), a taxa de juros \\(j\\) e o número de meses passados \\(n\\), podemos calcular o montante final \\(y\\) como \\[ y = x \\cdot (1 + j)^n\\text{.} \\] Até o momento, temos uma fórmula fechada da solução para o problema. E se eu dissesse que temos que resolvê-lo sem utilizar a operação de exponenciação? Como o problema seria resolvido? Uma opção seria \\[ y = x \\cdot \\underbrace{(1 + j) \\cdot \\text{...} \\cdot (1 + j)}_{n\\text{ vezes}}\\text{,} \\] ou interpretando as instruções: Multiplique \\(n\\) vezes o fator \\((1 + j)\\); Multiplique o resultado anterior pelo valor \\(x\\); Utilize o resultado anterior como resposta para o problema. A interpretação da fórmula acima começa a se aproximar do que estudaremos dentro da área de estudo que chamamos de Computação. Podemos ir além, e imaginar reescrever essa fórmula sem utilizar a operação de multiplicação. Ainda, imagine escrever a mesma fórmula usando apenas operadores lógicos de conjunção, disjunção e negação! É exatamente isso que os computadores digitais fazem: resolvem problemas computáveis por meio de sequências de operações lógicas e aritméticas. Eles são especialmente úteis para nos auxiliar neste tipo de tarefas, realizando-as mais eficientemente do que somos capazes. Um exemplo ubíquo de computador são as calculadoras. 1.2 Definições Nesta seção, definimos os principais conceitos utilizados ao longo do livro. 1.2.1 Computação As Ciências de Computação englobam o estudo de duas principais subáreas: os Sistemas Computacionais; e a Computação (ou Métodos Computacionais). De maneira geral, Sistemas Computacionais correspondem ao estudo de componentes de hardware, lógica digital, sistemas operacionais, segurança cibernética e outras tecnologias computacionais. Normalmente, em cursos de Engenharia de Computação e Engenharia Elétrica há maior ênfase nesses tópicos. Por outro lado, a Computação é uma Ciência Matemática com foco no estudo dos métodos que possibilitam e alimentam as tecnologias computacionais. Entre os tópicos de estudo estão a teoria da computação, linguagens de programação, algoritmos e estruturas de dados. Devido à ubiquidade de sistemas computacionais em nossa sociedade, a formação de todo engenheiro deve contemplar o entendimento e o domínio destes métodos para solução de problemas de engenharia. 1.2.2 Computador digital Computadores digitais são dispositivos eletrônicos capazes de processar informação por meio de operações lógicas e aritméticas. Como consequência de sua natureza digital são restritos ao processamento de informação discreta e finita. Esta limitação traz consigo características marcantes para as soluções computacionais. Quando lidamos com problemas computacionais, devemos levar em consideração restrições de hardware, escolha da tecnologia mais apropriada, custo computacional (custos relacionados ao tempo de execução, uso de memória e outros recursos computacionais), representação da informação (estruturas de dados), erros numéricos, bem como ponderar vantagens e desvantagens de cada algoritmo que potencialmente resolve o problema. Ao longo do livro, abordaremos cada um desses tópicos na profundidade suficiente para um engenheiro resolver os diversos problemas computacionais em sua carreira. 1.2.3 Dado digital Em computadores digitais, toda informação é representada por um conjunto finito de bits. Bit é a menor unidade de informação e pode assumir dois valores: zero ou um. Os bits são agrupados em unidades de informação chamadas de bytes, sendo este último a menor unidade endereçável de memória. Veremos, posteriormente, que cada byte armazenado em memória possui um endereço único. Esta propriedade afeta diversos aspectos das linguagens de programação, por exemplo, limitando o menor tamanho possível de objetos. Na grande maioria das arquiteturas modernas, um byte é composto por 8 bits. Na prática, apesar de cada byte ser endereçável, computadores digitais operam a nível de palavra. Ou seja, as operações lógicas e aritméticas são aplicadas em grupos de bytes. Uma palavra é a unidade natural de informação num computador. Como os bytes, o tamanho das palavras depende da arquitetura. Computadores de propósito geral modernos possuem palavras de tamanho 32 ou 64 bits. 1.2.4 Algoritmo Algoritmos são sequências de instruções para resolver um problema. Dada uma entrada, todo algoritmo deve ser: Não ambíguo: há uma, e somente uma, forma de executar cada instrução corretamente; Ordenado: existe uma, e somente uma, ordem correta de execução das instruções; e Finito: há um número finito de instruções que compõem um algoritmo. Entre exemplos do nosso dia a dia que são similares à algoritmos, podemos citar: Receitas de bolo; Instruções de montagem de um móvel; Regras para divisão de números naturais. A calculadora de juros compostos, apresentada na Seção 1.1, é um exemplo de algoritmo. 1.2.5 Programa de computador Um programa de computador é uma sequência de operações e instruções que realizam uma tarefa. Um programa é sempre executado num computador; e, ainda, são programas que fazem os computadores funcionarem, tornando-os úteis. Em outras palavras, programa de computador é a instância “concreta” de um algoritmo. 1.2.6 Programação e linguagem de programação Programas de computadores são representados e armazenados em computadores digitais numa linguagem ininteligível para nós humanos. De fato, chamamos essa linguagem de linguagem de máquina, composta por sequências de bits com significado específico para aquela arquitetura de computador. Assim, para que consigamos expressar programas de computador em linguagem compreensível, fazemos uso das linguagens de programação1. Cada linguagem de programação possui vantagens e desvantagens para diferentes aplicações. No entanto, todos os problemas computáveis podem ser resolvidos com qualquer linguagem de programação. Chamamos de programação o ato ou a habilidade de escrever programas numa determinada linguagem de programação. O arquivo que contém o programa escrito numa linguagem de programação é chamado de código-fonte. 1.2.7 Compilador Compiladores são programas de computador capazes de traduzir programas escritos numa linguagem de programação para uma determinada linguagem de máquina. Em geral, eles atuam em vários passos até chegar na representação final do programa. Eles também são responsáveis por verificar a corretude do código-fonte, normalmente auxiliando o programador a resolver possíveis erros. A representação final gerada pelo compilador, em linguagem de máquina, é chamada de código executável ou, simplesmente, executável. 1.2.8 Interpretador Uma alternativa à compilação é a interpretação. Interpretadores são programas de computador capazes de entender o código-fonte e executá-los por conta própria ao invés de gerar o executável. A execução interpretada é mais lenta do que a execução de um programa em linguagem de máquina devido ao programa intermediário: o interpretador. Outras vantagens e desvantagens menos triviais dos compiladores e interpretadores estão fora do escopo desse livro. 1.3 Considerações finais Uma vez motivados e com base nessas definições, podemos ir para o que mais importa: como construir soluções para os problemas computacionais por meio de programas de computador. Neste livro nos limitaremos nas linguagens de programação de alto nível e que são Turing completas.↩︎ "],["programas.html", "2 Introdução à programação 2.1 Breve histórico das linguagens de programação 2.2 Linguagem de alto nível 2.3 Primeiro programa 2.4 Sobre C++ 2.5 Programação imperativa", " 2 Introdução à programação Linguagens de alto nível, meu primeiro programa. 2.1 Breve histórico das linguagens de programação Conforme vimos no capítulo anterior, programas de computadores são, comumente, representados por uma linguagem específica, chamada linguagem de máquina, para uma determinada arquitetura de computador. Assim, cada palavra codifica uma instrução a ser executada pela máquina. Considere o seguinte computador para ilustrar esse conceito: Cada palavra é formada por 2 bytes, ou seja, 16 bits; Há disponível para escrita do programa 32 palavras de memória (64 bytes endereçáveis); Realiza operações aritméticas em números inteiros. Para as instruções, cada palavra é interpretada da seguinte maneira: Os 4 primeiros bits representam o código de operação; Os 6 próximos bits representam um endereço (addr1); Os 6 últimos bits representam um outro endereço de memória (addr2). As seguintes operações estão disponíveis: Instrução Código de Op. Descrição Leitura 0000 Lê número inteiro e armazena em addr1. Escrita 0001 Escreve número inteiro armazenado em addr1. Salto incondicional 0010 Salta para instrução em addr1. Salto se zero 0011 Salta para instrução em addr1 se addr2 contém zero. Salto se positivo 0100 Salta para instrução em addr1 se addr2 contém número positivo. Soma 0101 Realiza operação addr1 + addr2 e armazena em addr1. Subtração 0110 Realiza operação addr1 - addr2 e armazena em addr1. Multiplicação 0111 Realiza operação addr1 * addr2 e armazena em addr1. Divisão 1000 Realiza operação addr1 / addr2 e armazena em addr1. Resto 1001 Realiza operação addr1 % addr2 e armazena em addr1. Cópia 1110 Copia conteúdo em addr2 e armazena em addr1. Parar 1111 Para o programa e desliga o computador. Esse computador inicia o programa lendo a posição de memória 0 executando as instruções uma a uma até encontrar uma instrução de parada. A princípio, as instruções são lidas sequencialmente, exceto ao encontrar uma instrução de salto, quando a ordem da leitura pode se alterar. Assim, um programa que lê números inteiros até encontrar um zero e imprime a somatória destes ficaria assim. Posição de memória Informação na memória 0: 0000 000110 000000 1: 0011 000110 000100 2: 0101 000111 000110 3: 0010 000000 000000 4: 0001 000111 000000 5: 1111 000000 000000 6: 0000000000000000 7: 0000000000000000 Ignore por ora como os números (no caso 0) são representados nos 16 bits da palavra. Veremos mais detalhes sobre representação de dados mais a frente. Exercício: simule a execução desse programa com a entrada a seguinte entrada: 1, 4, 5, 10, 0. Obviamente, a linguagem de máquina não é apropriada para escrevermos programas legíveis para solução de problemas, especialmente aqueles mais complexos. Dentre as principais limitações, que tornam a linguagem de máquina de difícil compreensão, podemos citar: Há dependência do endereçamento de memória: as instruções se referem a posições fixas de memórias; assim, ao adicionarmos ou removermos instruções, outras instruções devem ser alteradas para manter o funcionamento correto do programa. A memorização dos comandos é difícil. Para resolver ambos estes problemas, podemos utilizar o conceito de abstração, ou seja, adicionar uma “camada” de semântica para esconder detalhes e facilitar a leitura do programa. As linguagens de montagem (assembly languages) introduzem dois principais conceitos para facilitar a escrita de programas: Uso de mnemônicos ao invés de códigos de operação; e Endereçamento simbólico. Mnemônicos são códigos alfabéticos que abstraem os códigos de operação para facilitar a leitura dos comandos. Por exemplo, para a nossa linguagem ilustrativa temos: Instrução Mnemônico Leitura READ Escrita WRITE Salto incondicional JUMP Salto se zero JMPZ Salto se positivo JMPP Soma ADD Subtração SUB Multiplicação MULT Divisão DIV Resto REM Cópia COPY Parar STOP Já o endereçamento simbólico é a técnica de endereçar posições de memória por meio de nomes e não de valores numéricos. Assim, o programa anterior pode ser escrito nesse computador utilizando linguagem de montagem como: begin: READ x JMPZ x end ADD sum x JUMP begin end: WRITE sum STOP x: 0 sum: 0 Chamamos de montador (assembler) o programa de computador que converte o código em linguagem de montagem para linguagem de máquina. Basicamente, esse software traduz os mnemônicos e calcula as posições de memória baseado nos rótulos. Exercícios: Utilizando as instruções disponíveis nesse computador ilustrativo, implemente um programa em linguagem de montagem que: Um programa que escreve o valor absoluto de um número lido. Um programa que escreve 1 se o número lido é par, ou 0 caso contrário. Um programa que escreva a soma dos valores absolutos dos números ímpares lidos (interrompa ao ler zero). Como as restrições de memória interferem no desenvolvimento dos programas? O que acontece quando o programa se torna mais complexo? Como reaproveitar os códigos? 2.2 Linguagem de alto nível Note que as linguagens de montagem apresentam diversas limitações, especialmente quanto à organização do código: Dados e instruções não são discriminados entre si; Não há maneira de expressar claramente laços de execução; Não é possível organizar o código de maneira modular. Já as linguagens de programação de alto nível abstraem diversos detalhes da máquina, focando em expressividade, ou seja, com foco na facilidade de compreensão por humanos. Assim, conceitos mais naturais para representar passos de um programa – como repetições, condicionais explícitos, funções matemáticas – são introduzidos. Além disso, as linguagens de alto nível possuem mecanismos que permitem a modularização do código, possibilitando assim a construção de programas mais complexos como combinação de programas mais simples. Toda linguagem de programação possui uma sintaxe que define a estrutura em que deve ser escrita. Nas linguagens de programação de alto nível, além da sintaxe, a semântica dos dados também deve ser respeitada. De maneira geral, podemos dividir um programa em níveis de complexidade, ou seja, aplicarmos o conceito de abstração: Um programa é composto por subprogramas; Subprogramas são compostos por conjuntos de definições e sequências de comandos; Cada definição ou comando é uma sequência de tokens; e Cada token é a unidade léxica mínima do programa. Esse conceito de abstração também será útil futuramente quando aprendermos a encontrar soluções de grandes problema por meio de soluções simples para subproblemas. 2.3 Primeiro programa Como vimos anteriormente, linguagens de programação de alto nível permitem ao programador construir um software (programa) composto por diversos módulos (subprogramas). Neste caso, é necessário identificar o “ponto de entrada” do programa. Ou seja, dentre as diversas potenciais funcionalidades do programa, qual é a primeira instrução executada. Em C++20, o início do programa ocorre na função main. Esta é a função que o sistema operacional invoca quando o programa é executado — outras rotinas podem ser executadas antes da main, por exemplo, para inicializar variáveis globais; no entanto, estes detalhes estão fora do escopo deste livro. Veja mais informações aqui. // hello.cpp #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello, world!\\n&quot;; } Há várias nuances deste programa que entraremos em detalhes futuramente. No momento, é suficiente saber que esse arquivo, quando compilado e executado, resultará em uma saída com o texto \"Hello, world!\" seguido de quebra de linha. $ g++ -std=c++20 hello.cpp -o hello $ ./hello Hello, world! 2.4 Sobre C++ A linguagem C++ é uma linguagem de programação de alto nível de propósito geral. Qualquer problema computável pode ser resolvido usando a linguagem C++; ou seja, o modelo abstrato2 da linguagem C++ é Turing-completo. Ela é uma linguagem imperativa, na qual comandos (statements) são utilizados para alterar o estado do programa e, consequentemente, sua operação. Além disso, ao contrário das linguagens de montagem, a linguagem permite programação estruturada, organizando os comando em condicionais, laços, blocos e sub-rotinas. A principal especificação da linguagem C++ é o ISO/IEC 14882. Neste livro, utilizaremos o padrão ISO/IEC 14882:20203. Um excelente material de apoio quanto a especificação do C++20 é o site https://en.cppreference.com/w/. 2.5 Programação imperativa As linguagens de programação seguem determinados paradigmas de programação que determinam sua estrutura e funcionalidades. Sem dúvida, o paradigma imperativo é o mais comum. Em poucas palavras, a programação imperativa consiste em resolver problemas por meio de uma série de “ordens”, que chamamos de comandos. O programa então consiste numa sequência de comandos executados um a um. A seguir veremos as duas principais categorias de comandos de linguagens imperativas: atribuição e entrada/saída. 2.5.1 Atribuição Atribuição consiste em… auto x = 10; x = 12; 2.5.2 Entrada e saída #include &lt;iostream&gt; int main() { using std::cin; using std::cout; // ... } // ... cin &gt;&gt; x; // ... // ... cout &lt;&lt; x &lt;&lt; &#39;\\n&#39;; // ... Ignorando questões de implementação, como limitação de memória.↩︎ https://www.iso.org/standard/79358.html↩︎ "],["fluxo.html", "3 Controle de fluxo 3.1 Comandos condicionais 3.2 Comandos de seleção 3.3 Comandos de repetição 3.4 Interrupções 3.5 Tratamento de erros e exceções", " 3 Controle de fluxo Vimos anteriormente, instruções de um algoritmo possuem um ordem pré-estabelecida para serem executados. Em linguagens de alto nível, utilizamos comandos com semânticas bem definidas para estabelecer a sequência de execução das instruções. 3.1 Comandos condicionais 3.2 Comandos de seleção 3.3 Comandos de repetição 3.4 Interrupções 3.5 Tratamento de erros e exceções "],["io.html", "4 Entrada e saída", " 4 Entrada e saída "],["subprogramas.html", "5 Sub-rotinas e recursão 5.1 Recursão", " 5 Sub-rotinas e recursão 5.1 Recursão Muitos problemas computacionais possuem uma propriedade muito interessante: cada instância do problema pose ser subdividida em instâncias menores do mesmo problema. Assim, o algoritmo da solução para o problema é recursivo. Em termos de programação, uma função é dita recursiva se fizer uma chamada a si mesmo. Essa característica é natural em diversas fórmulas matemáticas conhecidas. Consequentemente, diversos problemas podem ser resolvidos de maneira simples quando tratados recursivamente. Por exemplo, definimos o fatorial de um número natural não nulo como \\(n! = n \\cdot (n - 1) \\cdot (n - 2) \\cdot \\dots \\cdot 1\\) e fatorial de zero, \\(0!\\), igual a \\(1\\). Sua formulação recursiva é: \\(n! = 1\\) para \\(n \\leq 1\\); e \\(n! = n \\cdot (n - 1)!\\) para \\(n &gt; 1\\). Traduzindo em termos computacionais, para resolver problemas recursivos, seguimos os seguintes passos: Identificar as instâncias mínimas do problema, ou seja, aquelas que não podem ser subdivididas. Essa instância também é chamada de condição de parada do algoritmo; Para as demais instâncias, reduzir a instância atual em instâncias menores do mesmo problema. Vamos reproduzir esses passos para implementação de um algoritmo recursivo para calcular a soma dos números inteiros entre \\(a\\) e \\(b\\) assumindo que \\(a \\leq b\\). Denotaremos tal soma como \\(s(a, b)\\). Passo 1: A instância mínima desse problema é o caso \\(a = b\\) de modo que o resultado é o próprio valor de \\(a\\) (ou \\(b\\)). Ou seja, \\(s(a, a) = a\\). Passo 2: Para os casos \\(a &lt; b\\), podemos reduzir o problema a partir da seguinte propriedade: \\(s(a, b) = s(a, c) + s(c + 1, b)\\) para todo \\(c\\) tal que \\(a \\leq c &lt; b\\). Deste modo, para o caso específico \\(c = a\\), temos que \\(s(a, b) = s(a, a) + s(a + 1, b)\\). Logo, a implementação deste algoritmo seria: int s(int a, int b) { if (a == b) return a; return s(a, a) + s(a + 1, b); } 5.1.1 Busca binária Dada uma sequência \\(v\\) com \\(n\\) objetos ordenados de maneira crescente, queremos verificar se um determinado objeto \\(k\\) pertence ou não à sequência. É possível escrever um algoritmo recursivo que resolve o problema sem a necessidade de passar por cada elemento \\(x \\in v\\). Para construção da solução, observamos a seguinte propriedade: Se \\(k &gt; v_i\\), sabemos que \\(k \\neq v_j\\) para todo \\(j \\leq i\\); e Se \\(k &lt; v_i\\), que \\(k \\neq v_j\\) para todo \\(j \\geq i\\). Assim, podemos construir uma solução recursiva para o problema. Passo 1: A instância mínima acontece quando \\(n = 0\\) e, consequentemente, \\(k \\not\\in v\\). Passo 2: Podemos subdividir o problema a depender do elemento \\(m = v_{\\lfloor n/2 \\rfloor}\\): Se \\(k = m\\), então \\(k \\in v\\); Se \\(k &lt; m\\), então buscamos \\(k\\) em \\([v_j : 1 &lt; j &lt; \\lfloor n/2 \\rfloor]\\); ou Se \\(k &gt; m\\), então buscamos \\(k\\) em \\([v_j : \\lfloor n/2 \\rfloor &lt; j \\leq n]\\). Exercícios: Com base na formulação recursiva do fatorial e nos passos para construção do algoritmo recursivo, implemente Escreva um algoritmo recursivo para cálculo do \\(i\\)-ésimo elemento da sequência Fibonacci. Escreva um algoritmo recursivo para cálculo do máximo divisor comum (Algoritmo de Euclides). Implemente o algoritmo recursivo de busca binária. Implemente uma função recursiva que calcule a soma dos dígitos decimais de um inteiro positivo. Implemente uma função recursiva para converter número inteiro decimal em sua forma binária. Implemente um algoritmo recursivo que calcule a representação em Gray Code usando \\(N\\) bits de um número \\(0 \\leq k \\leq 2^{N-1}\\). Para todos os algoritmos anteriores, implemente uma versão iterativa. Após ler o capitulo 8, derive qual a complexidade de tempo no pior caso da busca binária em termos do tamanho do vetor. "],["tipos.html", "6 Tipos avançados", " 6 Tipos avançados "],["memoria.html", "7 Memória e ponteiros", " 7 Memória e ponteiros "],["complexity.html", "8 Complexidade computacional 8.1 Importância da análise de complexidade", " 8 Complexidade computacional Neste capítulo, veremos noções básicas de complexidade de algoritmos. Note que não estudaremos formalmente ou profundamente os conceitos. O objetivo é prover intuição sobre os conceitos principais e habilitar o estudante a entender suas implicações na escolha dos algoritmos. 8.1 Importância da análise de complexidade Ao planejarmos a solução para um problema computacional, teremos que escolher uma entre várias possíveis alternativas. Diversos aspectos podem ser considerados para escolha, como facilidade de implementação, familiaridade, ou conveniência. No entanto, o ponto muito importante a ser considerado é eficiência do algoritmo. Podemos definir o conceito de eficiência em termos de dois pontos de vista: de tempo e de memória. Dependendo da situação, as diferenças de eficiência podem: Ser irrelevantes, isto é, ambos os algoritmos possuem eficiência similar para entradas de qualquer tamanho; ou Ser relevantes, isto é, apresentam custos significantemente diferentes, isto é, diferença proporcional ao tamanho da entrada. Muitas vezes, para pequenos problemas, a diferença entre algoritmos torna-se irrelevante. Por isso, o foco deste capítulo é analisar o custo computacional dos algoritmos assintoticamente, ou seja, para entradas muito grandes. Veremos, na próxima parte do livro, como estes conceitos se aplicam também na escolha das estruturas de dados. Exercícios: Escreva um programa que ordene um vetor numérico com tamanho e valores arbitrários. Derive a função de custo de tempo em função do tamanho do vetor de entrada no pior caso. Indique a ordem de complexidade (notação O-grande) de tempo e de espaço do seu algoritmo. Escreva um algoritmo para encontrar o menor valor num vetor. Qual a ordem de complexidade de tempo no pior caso? Escreva um algoritmo para verificar se determinado elemento está num vetor. Qual a ordem de complexidade de tempo no pior caso do seu algoritmo? Considerando que o vetor está ordenado, escreva um algoritmo que tem ordem de complexidade \\(O(\\log n)\\). Escreva um algoritmo recursivo para cálculo do máximo divisor comum (Algoritmo de Euclides). Qual a ordem de complexidade de tempo em função das entradas no pior caso? Dica: procure na literatura a prova que utiliza sequência de Fibonacci. Considerando as funções do tempo de execução abaixo, indique a ordem de complexidade no pior caso para cada uma delas. \\(2 n + 10\\) \\(\\frac{1}{3} n (n + 2)\\) \\(n + \\sqrt n\\) \\(n + 100 n^{0.1}\\) \\(2^n + 3 n + n^{10}\\) \\(n^2 + n \\log n\\) \\(\\log_3 n + \\log_2 n\\) "],["tipos-abstratos-de-dados.html", "9 Tipos abstratos de dados", " 9 Tipos abstratos de dados Um tipo abstrato de dados é uma classe de objetos cujo comportamento lógico é definido por um conjunto de valores e operações (Dale and Walker 1996). Exemplo: conjuntos de números inteiros (veja vídeo). Exercícios: Defina e implemente um TAD para pontos num plano. Defina e implemente um TAD para polígonos gerais. Defina e implemente um TAD para números complexos e implemente. Implemente o TAD “Conjunto de Números Inteiros” com as seguintes operações: criar conjunto vazio, criar conjunto a partir de um intervalo finito, união, intersecção, diferença, e verificar se contém um determinado número. References "],["sequências.html", "10 Sequências 10.1 Listas 10.2 Iterador 10.3 Colônia", " 10 Sequências Há dois principais tipos de sequências: lista e colônia4. Listas são estruturas de dados cujos elementos podem ser acessados sequencialmente preservando a ordem destes. Colônias, por sua vez, sacrificam a ordem dos elementos para garantir outras propriedades desejadas. 10.1 Listas 10.1.1 Modelo abstrato e operações em listas Para definir o nosso modelo abstrato de lista, vamos começar pelas operações desejáveis. Operações comuns em listas. Operação Parâmetros Descrição Criar Capacidade Cria uma lista com capacidade especificada (potencialmente ilimitada5). Copiar Cria uma cópia da lista. Esvaziar Esvazia a lista. Acessar Posição Acessa um elemento da lista dada uma posição. Inserir Elemento, Posição Insere um elemento numa posição específica da lista. Remover Posição Remove o elemento numa posição específica da lista. Concatenar Lista Concatena outra lista no fim da lista. Separar Posição Separa a lista em duas a partir duma determinada posição. Além dessas operações, há outras mais triviais, como consultar o tamanho, consultar a capacidade, verificar se está cheia, e verificar se está vazia. Em C++17, podemos definir uma interface6 básica: template &lt;typename T&gt; class list { public: explicit list(std::size_t capacity); ~list() noexcept; list(const list&amp;); list(list&amp;&amp;) noexcept; auto operator=(const list&amp;) -&gt; list&amp;; auto operator=(list&amp;&amp;) noexcept -&gt; list&amp;; auto empty() -&gt; void; auto size() const -&gt; std::size_t; auto capacity() const -&gt; std::size_t; auto is_empty() const -&gt; bool; auto is_full() const -&gt; bool; auto at(std::size_t) -&gt; T&amp;; auto front() -&gt; T&amp;; auto back() -&gt; T&amp;; auto insert(std::size_t, T) -&gt; void; auto remove(std::size_t) -&gt; void; auto concat(list&lt;T&gt;) -&gt; void; auto split(std::size_t) -&gt; list&lt;T&gt;; }; Uma vez que levantamos as operações desejáveis da lista, veremos diferentes estruturas de dados que contemplam essa finalidade. Veremos também que cada uma delas apresentará diferentes vantagens e desvantagens em termos de complexidade de tempo. Além disso, dependendo da estrutura que escolhermos, mudaremos alguns detalhes da nossa interface para melhor adequá-la ao contexto. 10.1.2 Implementações de listas Nas implementações, não vamos usar os containers da STL (std::vector, std::list, etc) por motivos didáticos. 10.1.2.1 Lista contígua estática template &lt;typename T, std::size_t N&gt; class list { public: list() = default; // ... private: using storage_type = std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt;; std::array&lt;storage_type, N&gt; values_; std::size_t size_ = 0u; }; Não precisamos implementar o construtor. Exercício: Por que o construtor padrão (gerado pelo compilador) é suficiente neste caso? Limpando a lista: template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::empty() { if constexpr (!std::is_trivially_destructible_v&lt;T&gt;) for (std::size_t i = 0; i &lt; size_; ++i) std::destroy_at(std::address_of(values_[i])); size_ = 0; } Com esta operação, a implementação do destrutor torna-se bastante simples: template &lt;typename T, std::size_t N&gt; list&lt;T, N&gt;::~list() noexcept { empty(); } Checando as margens: template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::is_empty() const -&gt; bool { return size_ == 0; } template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::is_full() const -&gt; bool { return size_ == N; } Os construtores de cópia e movimentação são triviais: template &lt;typename T, std::size_t N&gt; list&lt;T, N&gt;::list(const list&amp; source) { for (std::size_t i = 0; i &lt; source.size_; ++i) ::new (std::address_of(values_[i])) T(source.values_[i]); size_ = source.size_; } template &lt;typename T, std::size_t N&gt; list&lt;T, N&gt;::list(list&amp;&amp; source) noexcept { for (std::size_t i = 0; i &lt; source.size_; ++i) ::new (std::address_of(values_[i])) T(std::move(source.values_[i])); size_ = std::exchange(source.size_, 0u); } Exercícios: Implementar as operações de atribuição (cópia e movimentação) eficientemente. Implementar versão destas operações (construtores e atribuições) garantias de exceção fortes nestas operações (sem utilizar funções prontas da biblioteca padrão). 10.1.3 Contíguo dinâmico template &lt;typename T&gt; class list { public: // ... private: using storage_type = std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt;; std::unique_ptr&lt;storage_type[]&gt; values_; std::size_t capacity_; std::size_t size_ = 0u; }; 10.1.3.1 Simplesmente encadeada 10.1.3.2 Duplamente encadeada 10.1.3.3 Possíveis aprimoramentos 10.2 Iterador 10.3 Colônia Em inglês, colony.↩︎ Ilimitada conceitualmente; toda estrutura digital possui limitações de armazenamento.↩︎ Não no sentido de orientação à objeto, mas em um sentido mais amplo.↩︎ "],["adaptadores.html", "11 Adaptadores", " 11 Adaptadores Pilha (LIFO), fila (FIFO), lista de prioridade "],["árvores.html", "12 Árvores 12.1 Árvores binárias", " 12 Árvores 12.1 Árvores binárias template &lt;typename T&gt; struct btree; template &lt;typename T&gt; using btree_ptr = std::shared_ptr&lt;btree&lt;T&gt;&gt;; template &lt;typename T&gt; struct btree { T value; btree_ptr left_child = nullptr; btree_ptr right_child = nullptr; }; enum class ordering { in_order, pre_order, post_order, }; template &lt;typename T&gt; using visitor = std::function&lt;bool(const T&amp;)&gt;; template &lt;typename T&gt; void dfs(btree_ptr&lt;T&gt; root, ordering order, const visitor&amp; visit) { if (root == nullptr) return; switch (order) { case in_order: dfs(root-&gt;left_child, order, visit); if (!visit(root-&gt;value)) return; dfs(root-&gt;right_child, order, visit); break; case pre_order: dfs(root-&gt;left_child, order, visit); dfs(root-&gt;right_child, order, visit); if (!visit(root-&gt;value)) return; break; case post_order: if (!visit(root-&gt;value)) return; dfs(root-&gt;left_child, order, visit); dfs(root-&gt;right_child, order, visit); break; } } template &lt;typename T&gt; void bfs(btree_ptr&lt;T&gt; root, const visitor&amp; visit) { std::queue&lt;btree_ptr&gt; queue; queue.push(root); while (!queue.empty()) { if (queue.front() == nullptr) { queue.pop(); continue; } if (!visit(queue.front()-&gt;value)) return; queue.push(queue.front()-&gt;left_child); queue.push(queue.front()-&gt;right_child); queue.pop(); } } "],["estruturas-associativas.html", "13 Estruturas associativas 13.1 Árvores Binárias de Busca", " 13 Estruturas associativas Conjuntos e mapas ordenados (árvores) e não ordenados (hashing) 13.1 Árvores Binárias de Busca template &lt;typename K, typename V&gt; class bstree { struct node_data; using node = std::shared_ptr&lt;node_data&gt;; struct node_data { K key; V value; node left_child = nullptr; node right_child = nullptr; }; public: void insert(const K&amp; key, const V&amp; value) { root = insert_recursive(root, key, value); } void remove(const K&amp; key) { root = remove_recursive(root, key); } auto search(const K&amp; key) const -&gt; std::optional&lt;V&gt; { const auto pos = search_recursive(root, key); if (pos != nullptr) return pos-&gt;value; return std::nullopt; } private: node root = nullptr; static auto insert_recursive( node root, const K&amp; key, const V&amp; value) -&gt; node { if (root == nullptr) return node(new node_data{key, value}); if (key &lt; root-&gt;key) root-&gt;left_child = insert_recursive(root-&gt;left_child, key, value); else if (key &gt; root-&gt;key) root-&gt;right_child = insert_recursive(root-&gt;right_child, key, value); return root; } static auto remove_recursive(node root, const K&amp; key) -&gt; node { if (root == nullptr) return nullptr; if (key &lt; root-&gt;key) { root-&gt;left_child = remove_recursive(root-&gt;left_child, key); return root; } if (key &gt; root-&gt;key) { root-&gt;right_child = remove_recursive(root-&gt;right_child, key); return root; } if (root-&gt;left_child == nullptr &amp;&amp; root-&gt;right_child == nullptr) return nullptr; if (root-&gt;left_child != nullptr &amp;&amp; root-&gt;right_child != nullptr) { const auto child = left_most(root-&gt;right_child); std::swap(root-&gt;key, child-&gt;key); root-&gt;right_child = remove_recursive(root-&gt;right_child, child-&gt;key); return root; } return root-&gt;left_child != nullptr ? root-&gt;left_child : root-&gt;right_child; } static auto left_most(node root) -&gt; node { return root-&gt;left_child == nullptr ? root : left_most(root-&gt;left_child); } static auto search_recursive(node root, K key) -&gt; node { if (root == nullptr) return nullptr; if (key &lt; root-&gt;key) return search_recursive(root-&gt;left_child, key); if (key &gt; root-&gt;key) return search_recursive(root-&gt;right_child, key); return root; } }; "],["particionamento.html", "14 Particionamento", " 14 Particionamento "],["ordenação.html", "15 Ordenação 15.1 Bubble sort 15.2 Shaker sort 15.3 Selection sort 15.4 Insertion sort 15.5 Shell sort 15.6 Quick sort 15.7 Merge sort", " 15 Ordenação OBS: questões de estabilidade na ordenação são omitidas neste livro. 15.1 Bubble sort template &lt;std::forward_iterator It&gt; void bubblesort(It begin, It end) { for (; begin != end; --end) for (auto left = begin, right = std::next(left); right != end; left = right++) if (*left &gt; *right) std::iter_swap(left, right); } Exercícios: Altere o código da função bubblesort para interromper as passagens quando não houver mais trocas. Compare o tempo de execução das duas versões da função bubblesort para vetores muito grandes. 15.2 Shaker sort template &lt;std::bidirectional_iterator It&gt; void shakersort(It begin, It end) { while (true) { for (auto left = begin, right = std::next(left); right != end; left = right++) if (*left &gt; *right) std::iter_swap(left, right); if (begin == --end) return; for (auto right = std::prev(end), left = std::prev(right); right != begin; right = left--) if (*left &gt; *right) std::iter_swap(left, right); if (++begin == end) return; } } Exercícios: Altere o código da função shakersort para interromper as passagens quando não houver mais trocas. Compare o tempo de execução das duas versões da função shakersort para vetores muito grandes. Qual algoritmo se beneficia mais desta interrupção: bubble sort ou shaker sort? 15.3 Selection sort template &lt;std::forward_iterator It&gt; void selectionsort(It begin, It end) { for (auto it = begin; it != end; ++it) std::iter_swap(it, std::min_element(it, end)); } 15.4 Insertion sort template &lt;std::bidirectional_iterator It&gt; void insertionsort(It begin, It end) { for (auto it = std::next(begin); it != end; ++it) for (auto right = it, left = std::prev(right); right != begin &amp;&amp; *left &gt; *right; right = left--) std::iter_swap(left, right); } 15.5 Shell sort template &lt;std::integral T&gt; auto knuth_seq_last(T length) { T h = 1; while (h &lt; length) h = 3 * h + 1; return h / 3; } template &lt;std::random_access_iterator It&gt; void shellsort(It begin, It end) { const auto length = std::distance(begin, end); for (auto h = knuth_seq_last(length); h &gt; 0; h = h / 3) for (auto it = std::next(begin, h); it != end; ++it) for (auto right = it, left = std::prev(right, h); std::distance(begin, right) &gt;= h &amp;&amp; *left &gt; *right; right = std::exchange(left, std::prev(left, h))) std::iter_swap(left, right); } Exercícios: Ignorando questões de desempenho, a função shellsort poderia ser implementada para iteradores bidirecionais (e sem acesso aleatório). Justifique a necessidade de acesso aleatório para manter as vantagens do shell sort em comparação com o insertion sort. 15.6 Quick sort template &lt;std::bidirectional_iterator It&gt; void quicksort(It begin, It end) { if (begin == end) return; auto left = begin; auto right = std::prev(end); const auto pivot_value = *left; while (true) { while (left != right &amp;&amp; *right &gt;= pivot_value) --right; if (left == right) break; std::iter_swap(left++, right); while (left != right &amp;&amp; *left &lt;= pivot_value) ++left; if (left == right) break; std::iter_swap(left, right--); } quicksort(begin, left); quicksort(std::next(left), end); } 15.7 Merge sort template &lt;std::forward_iterator It&gt; void merge(It begin, It mid, It end) { std::vector&lt;std::iter_value_t&lt;It&gt;&gt; tmp; auto it1 = begin, it2 = mid; while (it1 != mid &amp;&amp; it2 != end) tmp.push_back(std::move(*it1 &lt; *it2 ? *it1++ : *it2++)); std::move(it1, mid, back_inserter(tmp)); std::move(it2, end, back_inserter(tmp)); std::move(tmp.begin(), tmp.end(), begin); } template &lt;std::random_access_iterator It&gt; void mergesort(It begin, It end) { const auto length = std::distance(begin, end); if (length &lt; 2) return; const auto mid = std::next(begin, length / 2); merge_sort(begin, mid); merge_sort(mid, end); merge(begin, mid, end); } Exercícios: Discuta as desvantagens de permitir que a função mergesort aceite iteradores unidirecionais ao invés de requerer acesso aleatório. Implemente o algoritmo merge sort evitando as inúmeras alocações de memória temporária. "],["busca.html", "16 Busca", " 16 Busca "],["operações-de-conjuntos-em-listas-ordenadas.html", "17 Operações de conjuntos em listas ordenadas", " 17 Operações de conjuntos em listas ordenadas "],["operações-de-heap.html", "18 Operações de heap", " 18 Operações de heap "],["operações-numéricas.html", "19 Operações numéricas", " 19 Operações numéricas Transformação (apply, map), redução, produto interno (zip). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
