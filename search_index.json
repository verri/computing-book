[["index.html", "Computando Uma abordagem prática a programação, algoritmos e estruturas de dados Prefácio", " Computando Uma abordagem prática a programação, algoritmos e estruturas de dados Filipe A. N. Verri Lourenço A. Pereira Jr. 2021-03-13 Prefácio Já se perguntou o que, de fato, é Computação? Como ela está relacionada com a Informática? E com os computadores digitais? Estes conceitos são fortemente ligados, mas, de maneira alguma, são as mesmas coisas. Neste livro, pretendo, de uma maneira prática, expor estes conceitos e prepará-lo para o universo da programação independente da sua área de atuação. Espero que futuros engenheiros, cientistas da computação, cientistas de dados, biólogos, químicos, matemáticos e outros graduandos se beneficiem desse material. Veja que este não é um curso de programação numa linguagem específica, nem mesmo um curso de introdução às Ciências de Computação (o que julgo muito mais abrangente do que o escopo deste livro). No entanto, meu intuito é habilitá-los a resolver problemas computacionais de maneira organizada e efetiva, independentemente da linguagem de programação ou área de domínio. Inclusive, este não é um livro que tem como objetivo ensinar todos os aspectos de determinada linguagem de programação. Na medida do possível, os leitores serão direcionados a materiais específicos a esta ou aquela linguagem de programação. Apresentarei os principais algoritmos e estruturas de dados utilizados na atualidade – consequentemente sou forçado a deixar de fora tópicos históricos ou muito avançados. É altamente recomendado que o leitor tenha familiaridade com símbolos e notações matemáticas. A sequência dos tópicos e a profundidade de cada um deles é fortemente baseada na minha experiência nas disciplinas básicas de programação do Instituto Tecnológico de Aeronáutica, e devem funcionar muito bem para qualquer outro curso de engenharia. No entanto, peço encarecidamente que não utilizem esse material desatualizado – nada pior para os alunos do que aprender arcaísmos. Esta é uma área que está em constante evolução e assuntos desatualizados podem prejudicar significantemente os alunos que formamos. — Filipe Verri "],["sobre-os-autores.html", "Sobre os autores", " Sobre os autores Filipe Verri Lourenço Pereira Jr. "],["preliminares.html", "1 Preliminares 1.1 Motivação 1.2 História 1.3 Definições", " 1 Preliminares Neste capítulo, motivaremos a importância da computação em diversos domínios, contaremos um pouco da história da computação e como ela se relaciona com os desafios de nossa sociedade e, por fim, definiremos os principais termos e conceitos a serem abordados nos próximos capítulos. 1.1 Motivação Imagine instruir uma pessoa a calcular juros compostos. Dado que conhecemos o montante inicial \\(x\\), a taxa de juros \\(j\\) e o número de meses passados \\(n\\), podemos calcular o montante final \\(y\\) como \\[ y = x \\cdot (1 + j)^n\\text{.} \\] Até o momento, temos uma fórmula fechada da solução para o problema. E se eu dissesse que temos que resolvê-lo sem utilizar a operação de exponenciação? Como o problema seria resolvido? Uma opção seria \\[ y = x \\cdot \\underbrace{(1 + j) \\cdot \\text{...} \\cdot (1 + j)}_{n\\text{ vezes}}\\text{,} \\] ou interpretando as instruções: Multiplique o fator \\((1 + j)\\) \\(n\\) vezes; Multiplique o resultado anterior pelo valor \\(x\\); Utilize o resultado anterior como resposta para o problema. A interpretação da fórmula acima começa a se aproximar do que definiremos como computação. Podemos ir além, e imaginar reescrever essa fórmula sem utilizar a operação de multiplicação. Ainda, imagine escrever a mesma fórmula usando apenas operadores lógicos de conjunção, disjunção e negação! É exatamente isso que os computadores digitais fazem. 1.2 História 1.3 Definições 1.3.1 Computação 1.3.2 Computadores digitais 1.3.3 Dados 1.3.4 Algoritmos 1.3.5 Programação "],["representação-de-dados-digitais.html", "2 Representação de dados digitais", " 2 Representação de dados digitais Sistemas numéricos, representação de diferentes tipos. "],["lógica-digital.html", "3 Lógica digital", " 3 Lógica digital Operadores lógicos, circuitos lógicos. "],["algoritmos-1.html", "4 Algoritmos", " 4 Algoritmos Algoritmos, diagramas de fluxo, pseudo-código. "],["introdução-à-programação.html", "5 Introdução à programação 5.1 Primeiro programa de alto nível", " 5 Introdução à programação Arquitetura abstrata, linguagem de máquina, assembly, linguagens de alto nível, meu primeiro programa. 5.1 Primeiro programa de alto nível Como vimos anteriormente, linguagens de programação de alto nível permitem ao programador construir um software composto por diversos módulos. Neste caso, é necessário identificar o “ponto de entrada” do programa. Ou seja, dentre as diversas potenciais funcionalidades do programa, qual é a primeira instrução executada. Em C++20, o início do programa ocorre na função main. Esta é a função que o sistema operacional invoca quando o programa é executado — outras rotinas podem ser executadas antes da main, por exemplo, para inicializar variáveis globais; no entanto, estes detalhes estão fora do escopo deste livro. Veja mais informações aqui. #include &lt;iostream&gt; auto main() -&gt; int { std::cout &lt;&lt; &quot;Hello, world!\\n&quot;; } Há várias nuances deste programa que entraremos em detalhes futuramente. No momento, é suficiente saber que esse arquivo, quando compilado e executado, resultará em uma saída com o texto \"Hello, world!\" seguido de quebra de linha. "],["controle-de-fluxo.html", "6 Controle de fluxo 6.1 Comandos condicionais 6.2 Comandos de seleção 6.3 Comandos de repetição 6.4 Interrupções 6.5 Tratamento de erros e exceções", " 6 Controle de fluxo Vimos anteriormente que em Assembly, instruções de comparação e de salto podem ser utilizadas em conjunto para controlar o fluxo do programa. Em linguagens de alto nível, utilizamos comandos com semânticas melhor definidas. 6.1 Comandos condicionais 6.2 Comandos de seleção 6.3 Comandos de repetição 6.4 Interrupções 6.5 Tratamento de erros e exceções "],["entrada-e-saída.html", "7 Entrada e saída", " 7 Entrada e saída "],["subrotinas-e-recursão.html", "8 Subrotinas e recursão", " 8 Subrotinas e recursão "],["tipos-avançados.html", "9 Tipos avançados", " 9 Tipos avançados "],["memória-e-ponteiros.html", "10 Memória e ponteiros", " 10 Memória e ponteiros "],["complexidade-computacional.html", "11 Complexidade computacional", " 11 Complexidade computacional "],["listas.html", "12 Listas 12.1 Modelo abstrato e operações em listas 12.2 Implementações de listas 12.3 Iteradores", " 12 Listas Listas são estruturas de dados cujos elementos podem ser acessados sequencialmente. 12.1 Modelo abstrato e operações em listas Operações complexas em listas Operação Parâmetros Descrição Criar Capacidade Cria uma lista com capacidade especificada (potencialmente ilimitada1). Copiar Cria uma cópia da lista. Esvaziar Esvazia a lista. Acessar Posição Acessa um elemento da lista dada uma posição. Inserir Elemento, Posição Insere um elemento numa posição específica da lista. Remover Posição Remove o elemento numa posição específica da lista. Concatenar Lista Concatena outra lista no fim da lista. Separar Posição Separa a lista em duas a partir duma determinada posição. Além dessas operações, há outras mais triviais, como consultar o tamanho, consultar a capacidade, verificar se está cheia, e verificar se está vazia. Em C++20, podemos definir uma interface2 básica: template &lt;typename T&gt; class list { public: explicit list(std::size_t capacity); ~list(); list(const list&amp;); list(list&amp;&amp;); auto operator=(const list&amp;) -&gt; list&amp;; auto operator=(list&amp;&amp;) -&gt; list&amp;; auto empty() -&gt; void; auto size() const -&gt; std::size_t; auto capacity() const -&gt; std::size_t; auto is_empty() const -&gt; bool; auto is_full() const -&gt; bool; auto at(std::size_t) -&gt; T&amp;; auto front() -&gt; T&amp;; auto back() -&gt; T&amp;; auto insert(std::size_t, T) -&gt; void; auto remove(std::size_t) -&gt; void; auto concat(list&lt;T&gt;) -&gt; void; auto split(std::size_t) -&gt; list&lt;T&gt;; }; Veremos que dependendo da versão, podemos mudar uns detalhes da nossa interface para melhor adequá-la ao contexto. 12.2 Implementações de listas Nas implementações, não vamos usar os containers da STL (std::vector, std::list, etc) por motivos didáticos. 12.2.1 Contíguo estático template &lt;typename T, std::size_t N&gt; class list { public: list() = default; // ... private: using storage_type = std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt;; std::array&lt;storage_type, N&gt; values_; std::size_t size_ = 0u; }; Não precisamos de construtor. Não precisamos de um destrutor. Limpando a lista: template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::empty() { if constexpr (!std::is_trivially_destructible_v&lt;T&gt;) std::destroy(begin(values), begin(values) + size_); size_ = 0; } Checando as margens: template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::is_empty() const -&gt; bool { return size_ == 0; } template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::is_full() const -&gt; bool { return size_ == N; } 12.2.2 Contíguo dinâmico template &lt;typename T&gt; class list { public: // ... private: using storage_type = std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt;; std::unique_ptr&lt;storage_type[]&gt; values_; std::size_t capacity_; std::size_t size_ = 0u; }; 12.2.3 Simplesmente encadeada 12.2.4 Duplamente encadeada 12.2.5 Outros 12.3 Iteradores Ilimitada conceitualmente; toda estrutura digital possui limitações de armazenamento.↩︎ Não no sentido de orientação à objeto, mas em um sentido mais amplo.↩︎ "],["adaptadores.html", "13 Adaptadores", " 13 Adaptadores Pilha (LIFO), fila (FIFO), lista de prioridade "],["estruturas-associativas.html", "14 Estruturas associativas", " 14 Estruturas associativas Conjuntos e mapas ordenados (árvores) e não ordenados (hashing) "],["particionamento.html", "15 Particionamento", " 15 Particionamento "],["ordenação.html", "16 Ordenação", " 16 Ordenação "],["busca.html", "17 Busca", " 17 Busca "],["operações-de-conjuntos-em-listas-ordenadas.html", "18 Operações de conjuntos em listas ordenadas", " 18 Operações de conjuntos em listas ordenadas "],["operações-de-heap.html", "19 Operações de heap", " 19 Operações de heap "],["operações-numéricas.html", "20 Operações numéricas", " 20 Operações numéricas Transformação (apply, map), redução, produto interno (zip). "]]
