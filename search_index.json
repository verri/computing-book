[["index.html", "Computando Uma abordagem prática a programação, algoritmos e estruturas de dados Prefácio", " Computando Uma abordagem prática a programação, algoritmos e estruturas de dados Filipe A. N. Verri Lourenço A. Pereira Jr. 2021-08-09 Prefácio Já se perguntou o que, de fato, é Computação? Como ela está relacionada com a Informática? E com os computadores digitais? Estes conceitos são fortemente ligados, mas, de maneira alguma, são as mesmas coisas. Neste livro, pretendo, de uma maneira prática, expor estes conceitos e prepará-lo para o universo da programação independente da sua área de atuação. Espero que futuros engenheiros, cientistas da computação, cientistas de dados, biólogos, químicos, matemáticos e outros graduandos se beneficiem desse material. Veja que este não é um curso de programação numa linguagem específica, nem mesmo um curso de introdução às Ciências de Computação (o que julgo muito mais abrangente do que o escopo deste livro). No entanto, meu intuito é habilitá-los a resolver problemas computacionais de maneira organizada e efetiva, independentemente da linguagem de programação ou área de domínio. Inclusive, este não é um livro que tem como objetivo ensinar todos os aspectos de determinada linguagem de programação. Na medida do possível, os leitores serão direcionados a materiais específicos a esta ou aquela linguagem de programação. Apresentarei os principais algoritmos e estruturas de dados utilizados na atualidade – consequentemente sou forçado a deixar de fora tópicos históricos ou muito avançados. É altamente recomendado que o leitor tenha familiaridade com símbolos e notações matemáticas. A sequência dos tópicos e a profundidade de cada um deles é fortemente baseada na minha experiência nas disciplinas básicas de programação do Instituto Tecnológico de Aeronáutica, e devem funcionar muito bem para qualquer outro curso de engenharia. No entanto, peço encarecidamente que não utilizem esse material desatualizado – nada pior para os alunos do que aprender arcaísmos. Esta é uma área que está em constante evolução e assuntos desatualizados podem prejudicar significantemente os alunos que formamos. — Filipe Verri "],["sobre-os-autores.html", "Sobre os autores", " Sobre os autores Filipe Verri Lourenço Pereira Jr. "],["agradecimentos.html", "Agradecimentos", " Agradecimentos Agradeço ao Prof. Johnny Marques por disponibilizar seu material didático para o preparo do Capítulo sobre Complexidade Computacional e vários capítulos da Parte III Estruturas de Dados. "],["preliminares.html", "1 Preliminares 1.1 Motivação 1.2 História 1.3 Definições", " 1 Preliminares Neste capítulo, motivaremos a importância da computação em diversos domínios, contaremos um pouco da história da computação e como ela se relaciona com os desafios de nossa sociedade e, por fim, definiremos os principais termos e conceitos a serem abordados nos próximos capítulos. 1.1 Motivação Imagine instruir uma pessoa a calcular juros compostos. Dado que conhecemos o montante inicial \\(x\\), a taxa de juros \\(j\\) e o número de meses passados \\(n\\), podemos calcular o montante final \\(y\\) como \\[ y = x \\cdot (1 + j)^n\\text{.} \\] Até o momento, temos uma fórmula fechada da solução para o problema. E se eu dissesse que temos que resolvê-lo sem utilizar a operação de exponenciação? Como o problema seria resolvido? Uma opção seria \\[ y = x \\cdot \\underbrace{(1 + j) \\cdot \\text{...} \\cdot (1 + j)}_{n\\text{ vezes}}\\text{,} \\] ou interpretando as instruções: Multiplique o fator \\((1 + j)\\) \\(n\\) vezes; Multiplique o resultado anterior pelo valor \\(x\\); Utilize o resultado anterior como resposta para o problema. A interpretação da fórmula acima começa a se aproximar do que definiremos como computação. Podemos ir além, e imaginar reescrever essa fórmula sem utilizar a operação de multiplicação. Ainda, imagine escrever a mesma fórmula usando apenas operadores lógicos de conjunção, disjunção e negação! É exatamente isso que os computadores digitais fazem. 1.2 História 1.3 Definições 1.3.1 Computação 1.3.2 Computadores digitais 1.3.3 Dados 1.3.4 Algoritmos 1.3.5 Programação "],["lógica-digital.html", "2 Lógica digital", " 2 Lógica digital Operadores lógicos, circuitos lógicos. "],["representação-de-dados-digitais.html", "3 Representação de dados digitais 3.1 Tipos de informação", " 3 Representação de dados digitais Quando resolvemos um problema utilizando um programa de computador, é fundamental que planejemos a representação dos diferentes tipos de informações e o relacionamento entre eles. No entanto, somos limitados pelas restrições impostas pelos sistemas computacionais utilizados. Neste capítulo, vamos estudar os tipos de dados mais comuns e as diferentes maneiras de representá-los. 3.1 Tipos de informação Uma maneira proveitosa de estudar e organizar informações é encontrar os elementos indivisíveis que as compõem. Vamos considerar duas definições: Definição 3.1 (Informação escalar) Informação composta de um único elemento, indivisível. Definição 3.2 (Informação estruturada) Informação composta por mais de um elemento (escalar ou estruturado), podem ser dividas em partes menores. Para exemplificar estes conceitos, consideremos o problema de armazenar os dados de funcionários de uma empresa. Funcionários de uma empresa. Nome Endereço Data de nascimento Sexo Setor Salário Sherlock Holmes 221B Baker St., London 06/01/1954 M Jurídico £ 7.451,43 Dudley Dursley 4 Privet Drive, Little Whinging, Surrey 23/06/1980 M Administrativo £ 21.011,12 Homer Simpson 742 Evergreen Terrace, Springfield 12/05/1956 M Produção $ 1.951,18 Para cada um dos funcionários, as seguintes informações são registradas: nome, endereço, data de nascimento, sexo, setor que atua e seu salário. Assim, a representação do tipo “funcionário” é uma composição de texto, números, datas, categorias. Uma possível maneira de decompor este tipo é a seguinte (informações escalares são indicadas em negrito): Funcionário Nome Primeiro nome Sobrenome Endereço Número Logradouro Cidade País Data de nascimento Dia Mês Ano Sexo Setor Salário Moeda Valor É importante frisar que é possível que exista mais de uma decomposição válida para um mesmo problema. Isto vai depender dos objetivos, dos requisitos do sistema e, até mesmo, de limitações técnicas ou conveniências impostas pela linguagem de programação. Exercícios: Proponha uma decomposição alternativa para o tipo “funcionário” e justificar vantagens e desvantagens. Implemente, em uma linguagem de programação, a estrutura de dados para armazenar dados do tipo “funcionário”. Considere o desenvolvimento de um software para armazenar e manipular informações de livros disponíveis em um biblioteca. Proponha quais informações deverão ser consideradas e as classifique em escalar ou estruturada. Decomponha as informações estruturadas até os elementos indivisíveis. Agrupe as informações escalares de acordo com sua natureza. "],["algoritmos-1.html", "4 Algoritmos", " 4 Algoritmos Algoritmos, diagramas de fluxo, pseudo-código. "],["introdução-à-programação.html", "5 Introdução à programação 5.1 Primeiro programa de alto nível", " 5 Introdução à programação Arquitetura abstrata, linguagem de máquina, assembly, linguagens de alto nível, meu primeiro programa. 5.1 Primeiro programa de alto nível Como vimos anteriormente, linguagens de programação de alto nível permitem ao programador construir um software composto por diversos módulos. Neste caso, é necessário identificar o “ponto de entrada” do programa. Ou seja, dentre as diversas potenciais funcionalidades do programa, qual é a primeira instrução executada. Em C++20, o início do programa ocorre na função main. Esta é a função que o sistema operacional invoca quando o programa é executado — outras rotinas podem ser executadas antes da main, por exemplo, para inicializar variáveis globais; no entanto, estes detalhes estão fora do escopo deste livro. Veja mais informações aqui. #include &lt;iostream&gt; auto main() -&gt; int { std::cout &lt;&lt; &quot;Hello, world!\\n&quot;; } Há várias nuances deste programa que entraremos em detalhes futuramente. No momento, é suficiente saber que esse arquivo, quando compilado e executado, resultará em uma saída com o texto \"Hello, world!\" seguido de quebra de linha. "],["controle-de-fluxo.html", "6 Controle de fluxo 6.1 Comandos condicionais 6.2 Comandos de seleção 6.3 Comandos de repetição 6.4 Interrupções 6.5 Tratamento de erros e exceções", " 6 Controle de fluxo Vimos anteriormente que em Assembly, instruções de comparação e de salto podem ser utilizadas em conjunto para controlar o fluxo do programa. Em linguagens de alto nível, utilizamos comandos com semânticas melhor definidas. 6.1 Comandos condicionais 6.2 Comandos de seleção 6.3 Comandos de repetição 6.4 Interrupções 6.5 Tratamento de erros e exceções "],["entrada-e-saída.html", "7 Entrada e saída", " 7 Entrada e saída "],["subrotinas-e-recursão.html", "8 Subrotinas e recursão", " 8 Subrotinas e recursão "],["tipos-avançados.html", "9 Tipos avançados", " 9 Tipos avançados "],["memória-e-ponteiros.html", "10 Memória e ponteiros", " 10 Memória e ponteiros "],["complexidade-computacional.html", "11 Complexidade computacional 11.1 Importância da análise de complexidade", " 11 Complexidade computacional Neste capítulo, veremos noções básicas de complexidade de algoritmos. Note que não estudaremos formalmente ou profundamente os conceitos. O objetivo é prover intuição sobre os conceitos principais e habilitar o estudante a entender suas implicações na escolha dos algoritmos. 11.1 Importância da análise de complexidade Ao planejarmos a solução para um problema computacional, teremos que escolher uma entre várias possíveis alternativas. Diversos aspectos podem ser considerados para escolha, como facilidade de implementação, familiaridade, ou conveniência. No entanto, o ponto muito importante a ser considerado é eficiência do algoritmo. Podemos definir o conceito de eficiência em termos de dois pontos de vista: de tempo e de memória. Dependendo da situação, as diferenças de eficiência podem: Ser irrelevantes, isto é, ambos os algoritmos possuem eficiência similar para entradas de qualquer tamanho; ou Ser relevantes, isto é, apresentam custos significantemente diferentes, isto é, diferença proporcional ao tamanho da entrada. Muitas vezes, para pequenos problemas, a diferença entre algoritmos torna-se irrelevante. Por isso, o foco deste capítulo é analisar o custo computacional dos algoritmos assintoticamente, ou seja, para entradas muito grandes. Veremos, na próxima parte do livro, como estes conceitos se aplicam também na escolha das estruturas de dados. Exercícios: Escreva um programa que ordene um vetor numérico com tamanho e valores arbitrários. Derive a função de custo de tempo em função do tamanho do vetor de entrada no pior caso. Indique a ordem de complexidade (notação O-grande) de tempo e de espaço do seu algoritmo. Escreva um algoritmo para encontrar o menor valor num vetor. Qual a ordem de complexidade de tempo no pior caso? Escreva um algoritmo para verificar se determinado elemento está num vetor. Qual a ordem de complexidade de tempo no pior caso do seu algoritmo? Considerando que o vetor está ordenado, escreva um algoritmo que tem ordem de complexidade \\(O(\\log n)\\). Escreva um algoritmo recursivo para cálculo do máximo divisor comum (Algoritmo de Euclides). Qual a ordem de complexidade de tempo em função das entradas no pior caso? Dica: procure na literatura a prova que utiliza sequência de Fibonacci. Considerando as funções do tempo de execução abaixo, indique a ordem de complexidade no pior caso para cada uma delas. \\(2 n + 10\\) \\(\\frac{1}{3} n (n + 2)\\) \\(n + \\sqrt n\\) \\(n + 100 n^{0.1}\\) \\(2^n + 3 n + n^{10}\\) \\(n^2 + n \\log n\\) \\(\\log_3 n + \\log_2 n\\) "],["sequências.html", "12 Sequências 12.1 Listas 12.2 Iterador 12.3 Colônia", " 12 Sequências Há dois principais tipos de sequências: lista e colônia1. Listas são estruturas de dados cujos elementos podem ser acessados sequencialmente preservando a ordem destes. Colônias, por sua vez, sacrificam a ordem dos elementos para garantir outras propriedades desejadas. 12.1 Listas 12.1.1 Modelo abstrato e operações em listas Para definir o nosso modelo abstrato de lista, vamos começar pelas operações desejáveis. Operações comuns em listas. Operação Parâmetros Descrição Criar Capacidade Cria uma lista com capacidade especificada (potencialmente ilimitada2). Copiar Cria uma cópia da lista. Esvaziar Esvazia a lista. Acessar Posição Acessa um elemento da lista dada uma posição. Inserir Elemento, Posição Insere um elemento numa posição específica da lista. Remover Posição Remove o elemento numa posição específica da lista. Concatenar Lista Concatena outra lista no fim da lista. Separar Posição Separa a lista em duas a partir duma determinada posição. Além dessas operações, há outras mais triviais, como consultar o tamanho, consultar a capacidade, verificar se está cheia, e verificar se está vazia. Em C++17, podemos definir uma interface3 básica: template &lt;typename T&gt; class list { public: explicit list(std::size_t capacity); ~list() noexcept; list(const list&amp;); list(list&amp;&amp;) noexcept; auto operator=(const list&amp;) -&gt; list&amp;; auto operator=(list&amp;&amp;) noexcept -&gt; list&amp;; auto empty() -&gt; void; auto size() const -&gt; std::size_t; auto capacity() const -&gt; std::size_t; auto is_empty() const -&gt; bool; auto is_full() const -&gt; bool; auto at(std::size_t) -&gt; T&amp;; auto front() -&gt; T&amp;; auto back() -&gt; T&amp;; auto insert(std::size_t, T) -&gt; void; auto remove(std::size_t) -&gt; void; auto concat(list&lt;T&gt;) -&gt; void; auto split(std::size_t) -&gt; list&lt;T&gt;; }; Uma vez que levantamos as operações desejáveis da lista, veremos diferentes estruturas de dados que contemplam essa finalidade. Veremos também que cada uma delas apresentará diferentes vantagens e desvantagens em termos de complexidade de tempo. Além disso, dependendo da estrutura que escolhermos, mudaremos alguns detalhes da nossa interface para melhor adequá-la ao contexto. 12.1.2 Implementações de listas Nas implementações, não vamos usar os containers da STL (std::vector, std::list, etc) por motivos didáticos. 12.1.2.1 Lista contígua estática template &lt;typename T, std::size_t N&gt; class list { public: list() = default; // ... private: using storage_type = std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt;; std::array&lt;storage_type, N&gt; values_; std::size_t size_ = 0u; }; Não precisamos implementar o construtor. Exercício: Por que o construtor padrão (gerado pelo compilador) é suficiente neste caso? Limpando a lista: template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::empty() { if constexpr (!std::is_trivially_destructible_v&lt;T&gt;) for (std::size_t i = 0; i &lt; size_; ++i) std::destroy_at(std::address_of(values_[i])); size_ = 0; } Com esta operação, a implementação do destrutor torna-se bastante simples: template &lt;typename T, std::size_t N&gt; list&lt;T, N&gt;::~list() noexcept { empty(); } Checando as margens: template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::is_empty() const -&gt; bool { return size_ == 0; } template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::is_full() const -&gt; bool { return size_ == N; } Os construtores de cópia e movimentação são triviais: template &lt;typename T, std::size_t N&gt; list&lt;T, N&gt;::list(const list&amp; source) { for (std::size_t i = 0; i &lt; source.size_; ++i) ::new (std::address_of(values_[i])) T(source.values_[i]); size_ = source.size_; } template &lt;typename T, std::size_t N&gt; list&lt;T, N&gt;::list(list&amp;&amp; source) noexcept { for (std::size_t i = 0; i &lt; source.size_; ++i) ::new (std::address_of(values_[i])) T(std::move(source.values_[i])); size_ = std::exchange(source.size_, 0u); } Exercícios: Implementar as operações de atribuição (cópia e movimentação) eficientemente. Implementar versão destas operações (construtores e atribuições) garantias de exceção fortes nestas operações (sem utilizar funções prontas da biblioteca padrão). 12.1.3 Contíguo dinâmico template &lt;typename T&gt; class list { public: // ... private: using storage_type = std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt;; std::unique_ptr&lt;storage_type[]&gt; values_; std::size_t capacity_; std::size_t size_ = 0u; }; 12.1.3.1 Simplesmente encadeada 12.1.3.2 Duplamente encadeada 12.1.3.3 Possíveis aprimoramentos 12.2 Iterador 12.3 Colônia Em inglês, colony.↩︎ Ilimitada conceitualmente; toda estrutura digital possui limitações de armazenamento.↩︎ Não no sentido de orientação à objeto, mas em um sentido mais amplo.↩︎ "],["adaptadores.html", "13 Adaptadores", " 13 Adaptadores Pilha (LIFO), fila (FIFO), lista de prioridade "],["estruturas-associativas.html", "14 Estruturas associativas", " 14 Estruturas associativas Conjuntos e mapas ordenados (árvores) e não ordenados (hashing) "],["particionamento.html", "15 Particionamento", " 15 Particionamento "],["ordenação.html", "16 Ordenação", " 16 Ordenação "],["busca.html", "17 Busca", " 17 Busca "],["operações-de-conjuntos-em-listas-ordenadas.html", "18 Operações de conjuntos em listas ordenadas", " 18 Operações de conjuntos em listas ordenadas "],["operações-de-heap.html", "19 Operações de heap", " 19 Operações de heap "],["operações-numéricas.html", "20 Operações numéricas", " 20 Operações numéricas Transformação (apply, map), redução, produto interno (zip). "]]
