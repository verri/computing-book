[["index.html", "Computando Uma abordagem prática a programação, algoritmos e estruturas de dados Prefácio", " Computando Uma abordagem prática a programação, algoritmos e estruturas de dados Filipe A. N. Verri Lourenço A. Pereira Jr. 2021-11-18 Prefácio Já se perguntou o que, de fato, é Computação? Como ela está relacionada com a Informática? E com os computadores digitais? Estes conceitos são fortemente ligados, mas, de maneira alguma, são as mesmas coisas. Neste livro, pretendo, de uma maneira prática, expor estes conceitos e prepará-lo para o universo da programação independente da sua área de atuação. Espero que futuros engenheiros, cientistas da computação, cientistas de dados, biólogos, químicos, matemáticos e outros graduandos se beneficiem desse material. Veja que este não é um curso de programação numa linguagem específica, nem mesmo um curso de introdução às Ciências de Computação (o que julgo muito mais abrangente do que o escopo deste livro). No entanto, meu intuito é habilitá-los a resolver problemas computacionais de maneira organizada e efetiva, independentemente da linguagem de programação ou área de domínio. Inclusive, este não é um livro que tem como objetivo ensinar todos os aspectos de determinada linguagem de programação. Na medida do possível, os leitores serão direcionados a materiais específicos a esta ou aquela linguagem de programação. Apresentarei os principais algoritmos e estruturas de dados utilizados na atualidade – consequentemente sou forçado a deixar de fora tópicos históricos ou muito avançados. É altamente recomendado que o leitor tenha familiaridade com símbolos e notações matemáticas. A sequência dos tópicos e a profundidade de cada um deles é fortemente baseada na minha experiência nas disciplinas básicas de programação do Instituto Tecnológico de Aeronáutica, e devem funcionar muito bem para qualquer outro curso de engenharia. No entanto, peço encarecidamente que não utilizem esse material desatualizado – nada pior para os alunos do que aprender arcaísmos. Esta é uma área que está em constante evolução e assuntos desatualizados podem prejudicar significantemente os alunos que formamos. — Filipe Verri "],["sobre-os-autores.html", "Sobre os autores", " Sobre os autores Filipe Verri Lourenço Pereira Jr. "],["agradecimentos.html", "Agradecimentos", " Agradecimentos Agradeço ao Prof. Johnny Marques por disponibilizar seu material didático para o preparo do Capítulo sobre Complexidade Computacional e vários capítulos da Parte III Estruturas de Dados. "],["guia-ita.html", "Guia ITA", " Guia ITA Este livro é utilizado como bibliografia complementar nas disciplinas CES-10 e CES-11 do ITA. Para facilitar o acompanhamento destas disciplinas, disponibilizamos um guia conectando os tópicos da ementa com os capítulos deste livro. CES-10 – Introdução à Computação Ementa Capítulos Conceitos primários: computador, algoritmo, programa, linguagem de programação, compilador. Capítulo 1 Representação de informações: sistemas de numeração, mudança de base, aritmética binária, operações lógicas, textos e instruções. Capítulos 2 e 3 Evolução das linguagens de programação. Unidades básicas de um computador. Software básico para computadores. Desenvolvimento de algoritmos: linguagens para algoritmos e refinamento passo a passo. Comandos de uma linguagem procedimental: atribuição, entrada e saída, condicionais, repetitivos e seletivos. Variáveis escalares e estruturadas homogêneas e heterogêneas. Subprogramação: funções, procedimentos, passagem de parâmetros, recursividade. Ponteiros. CES-11 – Algoritmos e Estruturas de Dados I Ementa Capítulos Tópicos em recursividade. Técnicas para desenvolvimento de algoritmos. Noções de complexidade de algoritmos. Vetores e encadeamento de estruturas. Pilhas, filas e deques. Árvores gerais e binárias. Grafos orientados e não orientados. Algoritmos básicos para grafos. Filas de prioridades. Métodos básicos de Ordenação. Noções de programação orientada a objetos. "],["preliminares.html", "1 Preliminares 1.1 Motivação 1.2 Definições", " 1 Preliminares Neste capítulo, motivaremos a importância da computação em diversos domínios, contaremos um pouco da história da computação e como ela se relaciona com os desafios de nossa sociedade e, por fim, definiremos os principais termos e conceitos a serem abordados nos próximos capítulos. 1.1 Motivação Imagine instruir uma pessoa a calcular juros compostos. Dado que conhecemos o montante inicial \\(x\\), a taxa de juros \\(j\\) e o número de meses passados \\(n\\), podemos calcular o montante final \\(y\\) como \\[ y = x \\cdot (1 + j)^n\\text{.} \\] Até o momento, temos uma fórmula fechada da solução para o problema. E se eu dissesse que temos que resolvê-lo sem utilizar a operação de exponenciação? Como o problema seria resolvido? Uma opção seria \\[ y = x \\cdot \\underbrace{(1 + j) \\cdot \\text{...} \\cdot (1 + j)}_{n\\text{ vezes}}\\text{,} \\] ou interpretando as instruções: Multiplique \\(n\\) vezes o fator \\((1 + j)\\); Multiplique o resultado anterior pelo valor \\(x\\); Utilize o resultado anterior como resposta para o problema. A interpretação da fórmula acima começa a se aproximar do que definiremos como computação. Podemos ir além, e imaginar reescrever essa fórmula sem utilizar a operação de multiplicação. Ainda, imagine escrever a mesma fórmula usando apenas operadores lógicos de conjunção, disjunção e negação! É exatamente isso que os computadores digitais fazem. 1.2 Definições Nesta seção, definimos os principais conceitos utilizados ao longo do livro. 1.2.1 Computação As Ciências de Computação englobam o estudo de duas principais subáreas: os Sistemas Computacionais; e a Computação (ou Métodos Computacionais). De maneira geral, Sistemas Computacionais correspondem ao estudo de componentes de hardware, lógica digital, sistemas operacionais, segurança cibernética e outras tecnologias computacionais. Normalmente, em cursos de Engenharia de Computação e Engenharia Elétrica há maior ênfase nesses tópicos. Por outro lado, a Computação é uma Ciência Matemática com foco no estudo dos métodos que possibilitam e alimentam as tecnologias computacionais. Entre os tópicos de estudo estão a teoria da computação, linguagens de programação, algoritmos e estruturas de dados. Devido à ubiquidade de sistemas computacionais em nossa sociedade, a formação de todo engenheiro deve contemplar o entendimento e o domínio destes métodos para solução de problemas de engenharia. 1.2.2 Computador digital Computadores digitais são dispositivos eletrônicos capazes de processar informação por meio de operações lógicas e aritméticas. Como consequência de sua natureza digital são restritos ao processamento de informação discreta e finita. Esta limitação traz consigo características marcantes que diferem as soluções computacionais das soluções exatas (amplamente estudadas em disciplinas de matemática, física e similares no ensino básico e superior). Quando lidamos com problemas computacionais, devemos levar em consideração restrições de hardware, escolha da tecnologia mais apropriada, custo computacional (custos relacionados ao tempo de execução, uso de memória e outros recursos computacionais), representação da informação (estruturas de dados), erros numéricos, bem como ponderar vantagens e desvantagens de cada algoritmo que potencialmente resolve o problema. Ao longo do livro, abordaremos cada um desses tópicos na profundidade suficiente para um engenheiro resolver os diversos problemas computacionais em sua carreira. 1.2.3 Dado digital Em computadores digitais, toda informação é representada por um conjunto finito de bits. Bit é a menor unidade de informação e pode assumir dois valores: zero ou um. Os bits são agrupados em unidades de informação chamadas de bytes, sendo este último a menor unidade endereçável de memória. Veremos, posteriormente, que cada byte armazenado em memória possui um endereço único. Esta propriedade afeta diversos aspectos das linguagens de programação, por exemplo, limitando o menor tamanho possível de objetos. Na grande maioria das arquiteturas modernas, um byte é composto por 8 bits. Na prática, apesar de cada byte ser endereçável, computadores digitais operam a nível de palavra. Ou seja, as operações lógicas e aritméticas são aplicadas em grupos de bytes. Uma palavra é a unidade natural de informação em um computador. Como os bytes, o tamanho das palavras depende da arquitetura. Computadores de propósito geral modernos possuem palavras de tamanho 32 ou 64 bits. 1.2.4 Algoritmo WIP 1.2.5 Programa de computador Um programa de computador é uma sequência de operações e instruções que realizam uma tarefa. Um programa é sempre executado num computador; e, ainda, são programas que fazem os computadores funcionarem tornando-os úteis. Em outras palavras, programa de computador é a instância “concreta” de um algoritmo. 1.2.6 Programação e linguagem de programação WIP 1.2.7 Compilador WIP "],["logica.html", "2 Lógica digital", " 2 Lógica digital Operadores lógicos, circuitos lógicos. "],["representacao.html", "3 Representação de dados digitais 3.1 Tipos de informação", " 3 Representação de dados digitais Quando resolvemos um problema utilizando um programa de computador, é fundamental que planejemos a representação dos diferentes tipos de informações e o relacionamento entre eles. No entanto, somos limitados pelas restrições impostas pelos sistemas computacionais utilizados. Neste capítulo, vamos estudar os tipos de dados mais comuns e as diferentes maneiras de representá-los. 3.1 Tipos de informação Uma maneira proveitosa de estudar e organizar informações é encontrar os elementos indivisíveis que as compõem. Vamos considerar duas definições: Definição 3.1 (Informação escalar) Informação composta de um único elemento, indivisível. Definição 3.2 (Informação estruturada) Informação composta por mais de um elemento (escalar ou estruturado), podem ser dividas em partes menores. Para exemplificar estes conceitos, consideremos o problema de armazenar os dados de funcionários de uma empresa. Funcionários de uma empresa. Nome Endereço Data de nascimento Sexo Setor Salário Sherlock Holmes 221B Baker St., London 06/01/1954 M Jurídico £ 7.451,43 Dudley Dursley 4 Privet Drive, Little Whinging, Surrey 23/06/1980 M Administrativo £ 21.011,12 Homer Simpson 742 Evergreen Terrace, Springfield 12/05/1956 M Produção $ 1.951,18 Para cada um dos funcionários, as seguintes informações são registradas: nome, endereço, data de nascimento, sexo, setor que atua e seu salário. Assim, a representação do tipo “funcionário” é uma composição de texto, números, datas, categorias. Uma possível maneira de decompor este tipo é a seguinte (informações escalares são indicadas em negrito): Funcionário Nome Primeiro nome Sobrenome Endereço Número Logradouro Cidade País Data de nascimento Dia Mês Ano Sexo Setor Salário Moeda Valor É importante frisar que é possível que exista mais de uma decomposição válida para um mesmo problema. Isto vai depender dos objetivos, dos requisitos do sistema e, até mesmo, de limitações técnicas ou conveniências impostas pela linguagem de programação. Exercícios: Proponha uma decomposição alternativa para o tipo “funcionário” e justificar vantagens e desvantagens. Implemente, em uma linguagem de programação, a estrutura de dados para armazenar dados do tipo “funcionário”. Considere o desenvolvimento de um software para armazenar e manipular informações de livros disponíveis em um biblioteca. Proponha quais informações deverão ser consideradas e as classifique em escalar ou estruturada. Decomponha as informações estruturadas até os elementos indivisíveis. Agrupe as informações escalares de acordo com sua natureza. "],["algoritmos.html", "4 Algoritmos", " 4 Algoritmos Algoritmos, diagramas de fluxo, pseudo-código. "],["introdução-à-programação.html", "5 Introdução à programação 5.1 Linguagem de alto nível 5.2 Primeiro programa de alto nível", " 5 Introdução à programação Arquitetura abstrata, linguagem de máquina, assembly, linguagens de alto nível, meu primeiro programa. 5.1 Linguagem de alto nível Toda linguagem de programação possui uma sintaxe que define a estrutura em que deve ser escrita. Nas linguagens de programação de alto nível, além da sintaxe, a semântica dos elementos também deve ser respeitada. Por exemplo, ao contrário das linguagens de montagem, devemos seguir regras semânticas quanto ao tipo de cada variável do código. De maneira geral, podemos dividir um programa em níveis de complexidade, ou seja, aplicarmos o conceito de abstração: Um programa é composto por subprogramas; Subprogramas são compostos por conjuntos de definições e sequências de comandos; Cada definição ou comando é uma sequência de tokens; e Cada token é a unidade léxica mínima do programa. 5.2 Primeiro programa de alto nível Como vimos anteriormente, linguagens de programação de alto nível permitem ao programador construir um software composto por diversos módulos. Neste caso, é necessário identificar o “ponto de entrada” do programa. Ou seja, dentre as diversas potenciais funcionalidades do programa, qual é a primeira instrução executada. Em C++17, o início do programa ocorre na função main. Esta é a função que o sistema operacional invoca quando o programa é executado — outras rotinas podem ser executadas antes da main, por exemplo, para inicializar variáveis globais; no entanto, estes detalhes estão fora do escopo deste livro. Veja mais informações aqui. // hello.cpp #include &lt;iostream&gt; auto main() -&gt; int { std::cout &lt;&lt; &quot;Hello, world!\\n&quot;; } Há várias nuances deste programa que entraremos em detalhes futuramente. No momento, é suficiente saber que esse arquivo, quando compilado e executado, resultará em uma saída com o texto \"Hello, world!\" seguido de quebra de linha. $ g++ -std=c++17 hello.cpp -o hello $ ./hello Hello, world! "],["controle-de-fluxo.html", "6 Controle de fluxo 6.1 Comandos condicionais 6.2 Comandos de seleção 6.3 Comandos de repetição 6.4 Interrupções 6.5 Tratamento de erros e exceções", " 6 Controle de fluxo Vimos anteriormente que em Assembly, instruções de comparação e de salto podem ser utilizadas em conjunto para controlar o fluxo do programa. Em linguagens de alto nível, utilizamos comandos com semânticas melhor definidas. 6.1 Comandos condicionais 6.2 Comandos de seleção 6.3 Comandos de repetição 6.4 Interrupções 6.5 Tratamento de erros e exceções "],["entrada-e-saída.html", "7 Entrada e saída", " 7 Entrada e saída "],["sub-rotinas-e-recursão.html", "8 Sub-rotinas e recursão 8.1 Recursão", " 8 Sub-rotinas e recursão 8.1 Recursão Muitos problemas computacionais possuem uma propriedade muito interessante: cada instância do problema pose ser subdividida em instâncias menores do mesmo problema. Assim, o algoritmo da solução para o problema é recursivo. Em termos de programação, uma função é dita recursiva se fizer uma chamada a si mesmo. Essa característica é natural em diversas fórmulas matemáticas conhecidas. Consequentemente, diversos problemas podem ser resolvidos de maneira simples quando tratados recursivamente. Por exemplo, definimos o fatorial de um número natural não nulo como \\(n! = n \\cdot (n - 1) \\cdot (n - 2) \\cdot \\dots \\cdot 1\\) e fatorial de zero, \\(0!\\), igual a \\(1\\). Sua formulação recursiva é: \\(n! = 1\\) para \\(n \\leq 1\\); e \\(n! = n \\cdot (n - 1)!\\) para \\(n &gt; 1\\). Traduzindo em termos computacionais, para resolver problemas recursivos, seguimos os seguintes passos: Identificar as instâncias mínimas do problema, ou seja, aquelas que não podem ser subdivididas. Essa instância também é chamada de condição de parada do algoritmo; Para as demais instâncias, reduzir a instância atual em instâncias menores do mesmo problema. Vamos reproduzir esses passos para implementação de um algoritmo recursivo para calcular a soma dos números inteiros entre \\(a\\) e \\(b\\) assumindo que \\(a \\leq b\\). Denotaremos tal soma como \\(s(a, b)\\). Passo 1: A instância mínima desse problema é o caso \\(a = b\\) de modo que o resultado é o próprio valor de \\(a\\) (ou \\(b\\)). Ou seja, \\(s(a, a) = a\\). Passo 2: Para os casos \\(a &lt; b\\), podemos reduzir o problema a partir da seguinte propriedade: \\(s(a, b) = s(a, c) + s(c + 1, b)\\) para todo \\(c\\) tal que \\(a \\leq c &lt; b\\). Deste modo, para o caso específico \\(c = a\\), temos que \\(s(a, b) = s(a, a) + s(a + 1, b)\\). Logo, a implementação deste algoritmo seria: int s(int a, int b) { if (a == b) return a; return s(a, a) + s(a + 1, b); } 8.1.1 Busca binária Dada uma sequência \\(v\\) com \\(n\\) objetos ordenados de maneira crescente, queremos verificar se um determinado objeto \\(k\\) pertence ou não à sequência. É possível escrever um algoritmo recursivo que resolve o problema sem a necessidade de passar por cada elemento \\(x \\in v\\). Para construção da solução, observamos a seguinte propriedade: Se \\(k &gt; v_i\\), sabemos que \\(k \\neq v_j\\) para todo \\(j \\leq i\\); e Se \\(k &lt; v_i\\), que \\(k \\neq v_j\\) para todo \\(j \\geq i\\). Assim, podemos construir uma solução recursiva para o problema. Passo 1: A instância mínima acontece quando \\(n = 0\\) e, consequentemente, \\(k \\not\\in v\\). Passo 2: Podemos subdividir o problema a depender do elemento \\(m = v_{\\lfloor n/2 \\rfloor}\\): Se \\(k = m\\), então \\(k \\in v\\); Se \\(k &lt; m\\), então buscamos \\(k\\) em \\([v_j : 1 &lt; j &lt; \\lfloor n/2 \\rfloor]\\); ou Se \\(k &gt; m\\), então buscamos \\(k\\) em \\([v_j : \\lfloor n/2 \\rfloor &lt; j \\leq n]\\). Exercícios: Com base na formulação recursiva do fatorial e nos passos para construção do algoritmo recursivo, implemente Escreva um algoritmo recursivo para cálculo do \\(i\\)-ésimo elemento da sequência Fibonacci. Escreva um algoritmo recursivo para cálculo do máximo divisor comum (Algoritmo de Euclides). Implemente o algoritmo recursivo de busca binária. Implemente uma função recursiva que calcule a soma dos dígitos decimais de um inteiro positivo. Implemente uma função recursiva para converter número inteiro decimal em sua forma binária. Implemente um algoritmo recursivo que calcule a representação em Gray Code usando \\(N\\) bits de um número \\(0 \\leq k \\leq 2^{N-1}\\). Para todos os algoritmos anteriores, implemente uma versão iterativa. Após ler o capitulo 11, derive qual a complexidade de tempo no pior caso da busca binária em termos do tamanho do vetor. "],["tipos-avançados.html", "9 Tipos avançados", " 9 Tipos avançados "],["memória-e-ponteiros.html", "10 Memória e ponteiros", " 10 Memória e ponteiros "],["complexity.html", "11 Complexidade computacional 11.1 Importância da análise de complexidade", " 11 Complexidade computacional Neste capítulo, veremos noções básicas de complexidade de algoritmos. Note que não estudaremos formalmente ou profundamente os conceitos. O objetivo é prover intuição sobre os conceitos principais e habilitar o estudante a entender suas implicações na escolha dos algoritmos. 11.1 Importância da análise de complexidade Ao planejarmos a solução para um problema computacional, teremos que escolher uma entre várias possíveis alternativas. Diversos aspectos podem ser considerados para escolha, como facilidade de implementação, familiaridade, ou conveniência. No entanto, o ponto muito importante a ser considerado é eficiência do algoritmo. Podemos definir o conceito de eficiência em termos de dois pontos de vista: de tempo e de memória. Dependendo da situação, as diferenças de eficiência podem: Ser irrelevantes, isto é, ambos os algoritmos possuem eficiência similar para entradas de qualquer tamanho; ou Ser relevantes, isto é, apresentam custos significantemente diferentes, isto é, diferença proporcional ao tamanho da entrada. Muitas vezes, para pequenos problemas, a diferença entre algoritmos torna-se irrelevante. Por isso, o foco deste capítulo é analisar o custo computacional dos algoritmos assintoticamente, ou seja, para entradas muito grandes. Veremos, na próxima parte do livro, como estes conceitos se aplicam também na escolha das estruturas de dados. Exercícios: Escreva um programa que ordene um vetor numérico com tamanho e valores arbitrários. Derive a função de custo de tempo em função do tamanho do vetor de entrada no pior caso. Indique a ordem de complexidade (notação O-grande) de tempo e de espaço do seu algoritmo. Escreva um algoritmo para encontrar o menor valor num vetor. Qual a ordem de complexidade de tempo no pior caso? Escreva um algoritmo para verificar se determinado elemento está num vetor. Qual a ordem de complexidade de tempo no pior caso do seu algoritmo? Considerando que o vetor está ordenado, escreva um algoritmo que tem ordem de complexidade \\(O(\\log n)\\). Escreva um algoritmo recursivo para cálculo do máximo divisor comum (Algoritmo de Euclides). Qual a ordem de complexidade de tempo em função das entradas no pior caso? Dica: procure na literatura a prova que utiliza sequência de Fibonacci. Considerando as funções do tempo de execução abaixo, indique a ordem de complexidade no pior caso para cada uma delas. \\(2 n + 10\\) \\(\\frac{1}{3} n (n + 2)\\) \\(n + \\sqrt n\\) \\(n + 100 n^{0.1}\\) \\(2^n + 3 n + n^{10}\\) \\(n^2 + n \\log n\\) \\(\\log_3 n + \\log_2 n\\) "],["tipos-abstratos-de-dados.html", "12 Tipos abstratos de dados", " 12 Tipos abstratos de dados Um tipo abstrato de dados é uma classe de objetos cujo comportamento lógico é definido por um conjunto de valores e operações (Dale and Walker 1996). Exemplo: conjuntos de números inteiros (veja vídeo). Exercícios: Defina e implemente um TAD para pontos num plano. Defina e implemente um TAD para polígonos gerais. Defina e implemente um TAD para números complexos e implemente. Implemente o TAD “Conjunto de Números Inteiros” com as seguintes operações: criar conjunto vazio, criar conjunto a partir de um intervalo finito, união, intersecção, diferença, e verificar se contém um determinado número. References "],["sequências.html", "13 Sequências 13.1 Listas 13.2 Iterador 13.3 Colônia", " 13 Sequências Há dois principais tipos de sequências: lista e colônia1. Listas são estruturas de dados cujos elementos podem ser acessados sequencialmente preservando a ordem destes. Colônias, por sua vez, sacrificam a ordem dos elementos para garantir outras propriedades desejadas. 13.1 Listas 13.1.1 Modelo abstrato e operações em listas Para definir o nosso modelo abstrato de lista, vamos começar pelas operações desejáveis. Operações comuns em listas. Operação Parâmetros Descrição Criar Capacidade Cria uma lista com capacidade especificada (potencialmente ilimitada2). Copiar Cria uma cópia da lista. Esvaziar Esvazia a lista. Acessar Posição Acessa um elemento da lista dada uma posição. Inserir Elemento, Posição Insere um elemento numa posição específica da lista. Remover Posição Remove o elemento numa posição específica da lista. Concatenar Lista Concatena outra lista no fim da lista. Separar Posição Separa a lista em duas a partir duma determinada posição. Além dessas operações, há outras mais triviais, como consultar o tamanho, consultar a capacidade, verificar se está cheia, e verificar se está vazia. Em C++17, podemos definir uma interface3 básica: template &lt;typename T&gt; class list { public: explicit list(std::size_t capacity); ~list() noexcept; list(const list&amp;); list(list&amp;&amp;) noexcept; auto operator=(const list&amp;) -&gt; list&amp;; auto operator=(list&amp;&amp;) noexcept -&gt; list&amp;; auto empty() -&gt; void; auto size() const -&gt; std::size_t; auto capacity() const -&gt; std::size_t; auto is_empty() const -&gt; bool; auto is_full() const -&gt; bool; auto at(std::size_t) -&gt; T&amp;; auto front() -&gt; T&amp;; auto back() -&gt; T&amp;; auto insert(std::size_t, T) -&gt; void; auto remove(std::size_t) -&gt; void; auto concat(list&lt;T&gt;) -&gt; void; auto split(std::size_t) -&gt; list&lt;T&gt;; }; Uma vez que levantamos as operações desejáveis da lista, veremos diferentes estruturas de dados que contemplam essa finalidade. Veremos também que cada uma delas apresentará diferentes vantagens e desvantagens em termos de complexidade de tempo. Além disso, dependendo da estrutura que escolhermos, mudaremos alguns detalhes da nossa interface para melhor adequá-la ao contexto. 13.1.2 Implementações de listas Nas implementações, não vamos usar os containers da STL (std::vector, std::list, etc) por motivos didáticos. 13.1.2.1 Lista contígua estática template &lt;typename T, std::size_t N&gt; class list { public: list() = default; // ... private: using storage_type = std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt;; std::array&lt;storage_type, N&gt; values_; std::size_t size_ = 0u; }; Não precisamos implementar o construtor. Exercício: Por que o construtor padrão (gerado pelo compilador) é suficiente neste caso? Limpando a lista: template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::empty() { if constexpr (!std::is_trivially_destructible_v&lt;T&gt;) for (std::size_t i = 0; i &lt; size_; ++i) std::destroy_at(std::address_of(values_[i])); size_ = 0; } Com esta operação, a implementação do destrutor torna-se bastante simples: template &lt;typename T, std::size_t N&gt; list&lt;T, N&gt;::~list() noexcept { empty(); } Checando as margens: template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::is_empty() const -&gt; bool { return size_ == 0; } template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::is_full() const -&gt; bool { return size_ == N; } Os construtores de cópia e movimentação são triviais: template &lt;typename T, std::size_t N&gt; list&lt;T, N&gt;::list(const list&amp; source) { for (std::size_t i = 0; i &lt; source.size_; ++i) ::new (std::address_of(values_[i])) T(source.values_[i]); size_ = source.size_; } template &lt;typename T, std::size_t N&gt; list&lt;T, N&gt;::list(list&amp;&amp; source) noexcept { for (std::size_t i = 0; i &lt; source.size_; ++i) ::new (std::address_of(values_[i])) T(std::move(source.values_[i])); size_ = std::exchange(source.size_, 0u); } Exercícios: Implementar as operações de atribuição (cópia e movimentação) eficientemente. Implementar versão destas operações (construtores e atribuições) garantias de exceção fortes nestas operações (sem utilizar funções prontas da biblioteca padrão). 13.1.3 Contíguo dinâmico template &lt;typename T&gt; class list { public: // ... private: using storage_type = std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt;; std::unique_ptr&lt;storage_type[]&gt; values_; std::size_t capacity_; std::size_t size_ = 0u; }; 13.1.3.1 Simplesmente encadeada 13.1.3.2 Duplamente encadeada 13.1.3.3 Possíveis aprimoramentos 13.2 Iterador 13.3 Colônia Em inglês, colony.↩︎ Ilimitada conceitualmente; toda estrutura digital possui limitações de armazenamento.↩︎ Não no sentido de orientação à objeto, mas em um sentido mais amplo.↩︎ "],["adaptadores.html", "14 Adaptadores", " 14 Adaptadores Pilha (LIFO), fila (FIFO), lista de prioridade "],["estruturas-associativas.html", "15 Estruturas associativas", " 15 Estruturas associativas Conjuntos e mapas ordenados (árvores) e não ordenados (hashing) "],["particionamento.html", "16 Particionamento", " 16 Particionamento "],["ordenação.html", "17 Ordenação 17.1 Bubble sort 17.2 Shaker sort 17.3 Selection sort 17.4 Insertion sort 17.5 Shell sort 17.6 Quick sort 17.7 Merge sort", " 17 Ordenação 17.1 Bubble sort template &lt;typename ForwardIterator&gt; void bubble_sort(ForwardIterator begin, ForwardIterator end) { for (; begin != end; --end) for (auto left = begin, right = std::next(left); right != end; left = right++) if (*left &gt; *right) std::iter_swap(left, right); } Exercícios: Altere o código da função bubble_sort para interromper as passagens quando não houver mais trocas. Compare o tempo de execução das duas versões da função bubble_sort para vetores muito grandes. 17.2 Shaker sort template &lt;typename BidirIterator&gt; void shaker_sort(BidirIterator begin, BidirIterator end) { while (true) { for (auto left = begin, right = std::next(left); right != end; left = right++) if (*left &gt; *right) std::iter_swap(left, right); if (begin == --end) return; for (auto right = std::prev(end), left = std::prev(left); right != begin; right = left--) if (*left &gt; *right) std::iter_swap(left, right); if (++begin == end) return; } } Exercícios: Altere o código da função shaker_sort para interromper as passagens quando não houver mais trocas. Compare o tempo de execução das duas versões da função shaker_sort para vetores muito grandes. 17.3 Selection sort template &lt;typename ForwardIterator&gt; void selection_sort(ForwardIterator begin, ForwardIterator end) { for (auto it = begin; it != end; ++it) std::iter_swap(it, std::min_element(it, end)); } 17.4 Insertion sort template &lt;typename BidirIterator&gt; void insertion_sort(BidirIterator begin, BidirIterator end) { for (auto it = std::next(begin); it != end; ++it) for (auto right = it, left = std::prev(right); right != begin &amp;&amp; *left &gt; *right; right = left--) std::iter_swap(left, right); } 17.5 Shell sort template &lt;typename T&gt; auto knuth_seq_last(T length) { T h = 1; while (h &lt; length) h = 3 * h + 1; return h / 3; } template &lt;typename RandomAccessIterator&gt; void shell_sort(RandomAccessIterator begin, RandomAccessIterator end) { const auto length = std::distance(begin, end); for (auto h = knuth_seq_last(length); h &gt; 0; h = h / 3) for (auto it = std::next(begin, h); it != end; ++it) for (auto right = it, left = std::prev(right, h); right != begin &amp;&amp; *left &gt; *right; right = std::exchange(left, std::prev(left, h))) std::iter_swap(left, right); } 17.6 Quick sort template &lt;typename BidirIterator&gt; void quicksort(BidirIterator begin, BidirIterator end) { if (begin == end) return; auto left = begin; auto right = std::prev(end) const auto pivot_value = *left; while (true) { while (left != right &amp;&amp; *right &gt;= pivot_value) --right; if (left == right) break; std::iter_swap(left++, right); while (left != right &amp;&amp; *left &lt;= pivot_value) ++left; if (left == right) break; std::iter_swap(left, right--); } quicksort(begin, left); quicksort(left + 1, end); } 17.7 Merge sort template &lt;typename ForwardIterator&gt; void merge(ForwardIterator begin, ForwardIterator mid, ForwardIterator end) { using T = typename std::iterator_traits&lt;ForwardIterator&gt;::value_type; std::vector&lt;T&gt; tmp; auto it1 = begin; auto it2 = mid; while (it1 != mid &amp;&amp; it2 != end) tmp.push_back(std::move(*it1 &lt; *it2 ? *it1++ : *it2++)); std::move(it1, mid, std::back_inserter(tmp)); std::move(it2, end, std::back_inserter(tmp)); std::move(tmp.begin(), tmp.end(), begin); } template &lt;typename ForwardIterator&gt; void merge_sort(ForwardIterator begin, ForwardIterator end) { const auto length = std::distance(begin, end); if (length &lt; 2) return; const auto mid = std::next(begin, length / 2); merge_sort(begin, mid); merge_sort(mid, end); merge(begin, mid, end); } "],["busca.html", "18 Busca", " 18 Busca "],["operações-de-conjuntos-em-listas-ordenadas.html", "19 Operações de conjuntos em listas ordenadas", " 19 Operações de conjuntos em listas ordenadas "],["operações-de-heap.html", "20 Operações de heap", " 20 Operações de heap "],["operações-numéricas.html", "21 Operações numéricas", " 21 Operações numéricas Transformação (apply, map), redução, produto interno (zip). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
