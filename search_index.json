[["index.html", "Computando Uma abordagem prática a programação, algoritmos e estruturas de dados Prefácio", " Computando Uma abordagem prática a programação, algoritmos e estruturas de dados Filipe A. N. Verri Lourenço A. Pereira Jr. 2022-02-18 Prefácio Já se perguntou o que, de fato, é Computação? Como ela está relacionada com a Informática? E com os computadores digitais? Estes conceitos são fortemente ligados, mas, de maneira alguma, são as mesmas coisas. Neste livro, pretendo, de uma maneira prática, expor estes conceitos e prepará-lo para o universo da programação independente da sua área de atuação. Espero que futuros engenheiros, cientistas da computação, cientistas de dados, biólogos, químicos, matemáticos e outros graduandos se beneficiem desse material. Veja que este não é um curso de programação numa linguagem específica, nem mesmo um curso de introdução às Ciências de Computação (o que julgo muito mais abrangente do que o escopo deste livro). No entanto, meu intuito é habilitá-los a resolver problemas computacionais de maneira organizada e efetiva, independentemente da linguagem de programação ou área de domínio. Inclusive, este não é um livro que tem como objetivo ensinar todos os aspectos de determinada linguagem de programação. Na medida do possível, os leitores serão direcionados a materiais específicos a esta ou aquela linguagem de programação. Apresentarei os principais algoritmos e estruturas de dados utilizados na atualidade – consequentemente sou forçado a deixar de fora tópicos históricos ou muito avançados. É altamente recomendado que o leitor tenha familiaridade com símbolos e notações matemáticas. A sequência dos tópicos e a profundidade de cada um deles é fortemente baseada na minha experiência nas disciplinas básicas de programação do Instituto Tecnológico de Aeronáutica, e devem funcionar muito bem para qualquer outro curso de engenharia. No entanto, peço encarecidamente que não utilizem esse material desatualizado – nada pior para os alunos do que aprender arcaísmos. Esta é uma área que está em constante evolução e assuntos desatualizados podem prejudicar significantemente os alunos que formamos. — Filipe Verri "],["sobre-os-autores.html", "Sobre os autores", " Sobre os autores Filipe Verri Lourenço Pereira Jr. "],["agradecimentos.html", "Agradecimentos", " Agradecimentos Agradeço ao Prof. Johnny Marques por disponibilizar seu material didático para o preparo do Capítulo sobre Complexidade Computacional e vários capítulos da Parte III Estruturas de Dados. "],["guia-ita.html", "Guia ITA", " Guia ITA Este livro é utilizado como bibliografia complementar nas disciplinas CES-10 e CES-11 do ITA. Para facilitar o acompanhamento destas disciplinas, disponibilizamos um guia conectando os tópicos da ementa com os capítulos deste livro. CES-10 – Introdução à Computação Ementa Capítulos Conceitos primários: computador, algoritmo, programa, linguagem de programação, compilador. Capítulo 1 Representação de informações: sistemas de numeração, mudança de base, aritmética binária, operações lógicas, textos e instruções. Capítulos 2, 3 e 4 Evolução das linguagens de programação. Capítulo 6 Unidades básicas de um computador. Capítulo 6 Software básico para computadores. Capítulo 6 Desenvolvimento de algoritmos: linguagens para algoritmos e refinamento passo a passo. Capítulo 5 Comandos de uma linguagem procedimental: atribuição, entrada e saída, condicionais, repetitivos e seletivos. Capítulos 7 e 8 Variáveis escalares e estruturadas homogêneas e heterogêneas. Capítulos 6 e 10 Subprogramação: funções, procedimentos, passagem de parâmetros, recursividade. Capítulo 9 Ponteiros. Capítulo 11 CES-11 – Algoritmos e Estruturas de Dados I Ementa Capítulos Tópicos em recursividade. Técnicas para desenvolvimento de algoritmos. Noções de complexidade de algoritmos. Vetores e encadeamento de estruturas. Pilhas, filas e deques. Árvores gerais e binárias. Grafos orientados e não orientados. Algoritmos básicos para grafos. Filas de prioridades. Métodos básicos de Ordenação. Noções de programação orientada a objetos. "],["preliminares.html", "1 Preliminares 1.1 Motivação 1.2 Definições", " 1 Preliminares Neste capítulo, motivaremos a importância da computação em diversos domínios, contaremos um pouco da história da computação e como ela se relaciona com os desafios de nossa sociedade e, por fim, definiremos os principais termos e conceitos a serem abordados nos próximos capítulos. 1.1 Motivação Imagine instruir uma pessoa a calcular juros compostos. Dado que conhecemos o montante inicial \\(x\\), a taxa de juros \\(j\\) e o número de meses passados \\(n\\), podemos calcular o montante final \\(y\\) como \\[ y = x \\cdot (1 + j)^n\\text{.} \\] Até o momento, temos uma fórmula fechada da solução para o problema. E se eu dissesse que temos que resolvê-lo sem utilizar a operação de exponenciação? Como o problema seria resolvido? Uma opção seria \\[ y = x \\cdot \\underbrace{(1 + j) \\cdot \\text{...} \\cdot (1 + j)}_{n\\text{ vezes}}\\text{,} \\] ou interpretando as instruções: Multiplique \\(n\\) vezes o fator \\((1 + j)\\); Multiplique o resultado anterior pelo valor \\(x\\); Utilize o resultado anterior como resposta para o problema. A interpretação da fórmula acima começa a se aproximar do que definiremos como computação. Podemos ir além, e imaginar reescrever essa fórmula sem utilizar a operação de multiplicação. Ainda, imagine escrever a mesma fórmula usando apenas operadores lógicos de conjunção, disjunção e negação! É exatamente isso que os computadores digitais fazem. 1.2 Definições Nesta seção, definimos os principais conceitos utilizados ao longo do livro. 1.2.1 Computação As Ciências de Computação englobam o estudo de duas principais subáreas: os Sistemas Computacionais; e a Computação (ou Métodos Computacionais). De maneira geral, Sistemas Computacionais correspondem ao estudo de componentes de hardware, lógica digital, sistemas operacionais, segurança cibernética e outras tecnologias computacionais. Normalmente, em cursos de Engenharia de Computação e Engenharia Elétrica há maior ênfase nesses tópicos. Por outro lado, a Computação é uma Ciência Matemática com foco no estudo dos métodos que possibilitam e alimentam as tecnologias computacionais. Entre os tópicos de estudo estão a teoria da computação, linguagens de programação, algoritmos e estruturas de dados. Devido à ubiquidade de sistemas computacionais em nossa sociedade, a formação de todo engenheiro deve contemplar o entendimento e o domínio destes métodos para solução de problemas de engenharia. 1.2.2 Computador digital Computadores digitais são dispositivos eletrônicos capazes de processar informação por meio de operações lógicas e aritméticas. Como consequência de sua natureza digital são restritos ao processamento de informação discreta e finita. Esta limitação traz consigo características marcantes que diferem as soluções computacionais das soluções exatas (amplamente estudadas em disciplinas de matemática, física e similares no ensino básico e superior). Quando lidamos com problemas computacionais, devemos levar em consideração restrições de hardware, escolha da tecnologia mais apropriada, custo computacional (custos relacionados ao tempo de execução, uso de memória e outros recursos computacionais), representação da informação (estruturas de dados), erros numéricos, bem como ponderar vantagens e desvantagens de cada algoritmo que potencialmente resolve o problema. Ao longo do livro, abordaremos cada um desses tópicos na profundidade suficiente para um engenheiro resolver os diversos problemas computacionais em sua carreira. 1.2.3 Dado digital Em computadores digitais, toda informação é representada por um conjunto finito de bits. Bit é a menor unidade de informação e pode assumir dois valores: zero ou um. Os bits são agrupados em unidades de informação chamadas de bytes, sendo este último a menor unidade endereçável de memória. Veremos, posteriormente, que cada byte armazenado em memória possui um endereço único. Esta propriedade afeta diversos aspectos das linguagens de programação, por exemplo, limitando o menor tamanho possível de objetos. Na grande maioria das arquiteturas modernas, um byte é composto por 8 bits. Na prática, apesar de cada byte ser endereçável, computadores digitais operam a nível de palavra. Ou seja, as operações lógicas e aritméticas são aplicadas em grupos de bytes. Uma palavra é a unidade natural de informação em um computador. Como os bytes, o tamanho das palavras depende da arquitetura. Computadores de propósito geral modernos possuem palavras de tamanho 32 ou 64 bits. 1.2.4 Algoritmo WIP 1.2.5 Programa de computador Um programa de computador é uma sequência de operações e instruções que realizam uma tarefa. Um programa é sempre executado num computador; e, ainda, são programas que fazem os computadores funcionarem tornando-os úteis. Em outras palavras, programa de computador é a instância “concreta” de um algoritmo. 1.2.6 Programação e linguagem de programação WIP 1.2.7 Compilador WIP "],["numeros.html", "2 Sistemas de numeração 2.1 Conversão de base 2.2 Aritmética binária", " 2 Sistemas de numeração No nosso cotidiano, nós expressamos valores numéricos utilizando o sistema decimal de numeração. Em outras palavras, utilizamos dez algarismos diferentes que quando combinados representam diferentes grandezas. Ao combiná-los, levamos em consideração a posição relativa de cada algarismo para interpretar a grandeza que queremos representar. Deste modo, a grandeza representada por 17 é diferente da grandeza representada por 71, mesmo que utilizem os mesmos símbolos: 1 e 7. Podemos generalizar esse esquema para qualquer número de algarismos, criando diferentes sistemas de representação de números. Considere as seguintes definições. Definição 2.1 (Sistema de numeração) Sistema de escrita para representar números por meio de um alfabeto e uma regra de composição. Definição 2.2 (Sistema posicional) Sistema de numeração em que a contribuição de cada símbolo do alfabeto no valor do número é o valor do símbolo multiplicado por um fator dependente da posição do símbolo. Os valores associados a cada símbolo são crescentes, ou seja, o alfabeto é ordenado. O fator de multiplicação consiste em um múltiplo da base do sistema. Definição 2.3 (Base) Número de símbolos de um sistema posicional. Em um sistema posicional com base \\(b\\), um número inteiro representado por \\((a_n a_{n-1} \\cdots a_2 a_1 a_0)_b\\) possui grandeza \\[ \\sum_{i=0}^n v_i b^i\\text{,} \\] onde \\(v_i\\) é o valor do símbolo \\(a_i\\). Com base nas definições, podemos dizer que o sistema de numeração que utilizamos no nosso dia a dia é um sistema posicional de base 10 com alfabeto \\(\\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\}\\). Deste modo, o número \\((71)_{10}\\) representa o valor \\(1 \\cdot 10^0 + 7 \\cdot 10^1 = 71\\) enquanto o número \\((17)_{10}\\) representa o valor \\(7 \\cdot 10^0 + 1 \\cdot 10^1 = 17\\). Na computação, além da base \\(10\\), outros três sistemas são amplamente utilizados: Sistemas posicionais comuns na computação. Nome Base Alfabeto (ordenado) Binário 2 \\(\\{0, 1\\}\\) Octal 8 \\(\\{0, 1, 2, 3, 4, 5, 6, 7\\}\\) Decimal 10 \\(\\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\}\\) Hexadecimal 16 \\(\\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\\}\\) Note que uma mesma grandeza pode ser representada em diferentes bases. Por exemplo, verifique que \\((10)_{10} = (A)_{16} = (1010)_2 = (12)_8\\). Os sistemas posicionais também podem ser utilizados para representar número fracionais. Para isso, utilizaremos um separador (no caso, o símbolo “.”) que determina quais posições possuem fator com expoentes positivos ou negativos. Assim, o número fracional representado por \\((a_n a_{n-1} \\cdots a_2 a_1 a_0 . c_1 c_2 \\cdots)_b\\) possui grandeza \\[ \\sum_{i=0}^n v_i b^i + \\sum_{i=1}^\\infty w_i b^{-i}\\text{,} \\] onde \\(v_i\\) é o valor associado ao símbolo \\(a_i\\) e \\(w_i\\), ao símbolo \\(c_i\\). 2.1 Conversão de base 2.2 Aritmética binária "],["logica.html", "3 Lógica digital", " 3 Lógica digital Operadores lógicos, circuitos lógicos. "],["representacao.html", "4 Representação de dados digitais 4.1 Tipos de informação", " 4 Representação de dados digitais Quando resolvemos um problema utilizando um programa de computador, é fundamental que planejemos a representação dos diferentes tipos de informações e o relacionamento entre eles. No entanto, somos limitados pelas restrições impostas pelos sistemas computacionais utilizados. Neste capítulo, vamos estudar os tipos de dados mais comuns e as diferentes maneiras de representá-los. 4.1 Tipos de informação Uma maneira proveitosa de estudar e organizar informações é encontrar os elementos indivisíveis que as compõem. Vamos considerar duas definições: Definição 4.1 (Informação escalar) Informação composta de um único elemento, indivisível. Definição 4.2 (Informação estruturada) Informação composta por mais de um elemento (escalar ou estruturado), podem ser dividas em partes menores. Para exemplificar estes conceitos, consideremos o problema de armazenar os dados de funcionários de uma empresa. Funcionários de uma empresa. Nome Endereço Data de nascimento Sexo Setor Salário Sherlock Holmes 221B Baker St., London 06/01/1954 M Jurídico £ 7.451,43 Dudley Dursley 4 Privet Drive, Little Whinging, Surrey 23/06/1980 M Administrativo £ 21.011,12 Homer Simpson 742 Evergreen Terrace, Springfield 12/05/1956 M Produção $ 1.951,18 Para cada um dos funcionários, as seguintes informações são registradas: nome, endereço, data de nascimento, sexo, setor que atua e seu salário. Assim, a representação do tipo “funcionário” é uma composição de texto, números, datas, categorias. Uma possível maneira de decompor este tipo é a seguinte (informações escalares são indicadas em negrito): Funcionário Nome Primeiro nome Sobrenome Endereço Número Logradouro Cidade País Data de nascimento Dia Mês Ano Sexo Setor Salário Moeda Valor É importante frisar que é possível que exista mais de uma decomposição válida para um mesmo problema. Isto vai depender dos objetivos, dos requisitos do sistema e, até mesmo, de limitações técnicas ou conveniências impostas pela linguagem de programação. Exercícios: Proponha uma decomposição alternativa para o tipo “funcionário” e justificar vantagens e desvantagens. Implemente, em uma linguagem de programação, a estrutura de dados para armazenar dados do tipo “funcionário”. Considere o desenvolvimento de um software para armazenar e manipular informações de livros disponíveis em um biblioteca. Proponha quais informações deverão ser consideradas e as classifique em escalar ou estruturada. Decomponha as informações estruturadas até os elementos indivisíveis. Agrupe as informações escalares de acordo com sua natureza. "],["algoritmos.html", "5 Algoritmos", " 5 Algoritmos Algoritmos, diagramas de fluxo, pseudo-código. "],["programas.html", "6 Introdução à programação 6.1 Linguagem de alto nível 6.2 Primeiro programa de alto nível", " 6 Introdução à programação Arquitetura abstrata, linguagem de máquina, assembly, linguagens de alto nível, meu primeiro programa. 6.1 Linguagem de alto nível Toda linguagem de programação possui uma sintaxe que define a estrutura em que deve ser escrita. Nas linguagens de programação de alto nível, além da sintaxe, a semântica dos elementos também deve ser respeitada. Por exemplo, ao contrário das linguagens de montagem, devemos seguir regras semânticas quanto ao tipo de cada variável do código. De maneira geral, podemos dividir um programa em níveis de complexidade, ou seja, aplicarmos o conceito de abstração: Um programa é composto por subprogramas; Subprogramas são compostos por conjuntos de definições e sequências de comandos; Cada definição ou comando é uma sequência de tokens; e Cada token é a unidade léxica mínima do programa. 6.2 Primeiro programa de alto nível Como vimos anteriormente, linguagens de programação de alto nível permitem ao programador construir um software composto por diversos módulos. Neste caso, é necessário identificar o “ponto de entrada” do programa. Ou seja, dentre as diversas potenciais funcionalidades do programa, qual é a primeira instrução executada. Em C++20, o início do programa ocorre na função main. Esta é a função que o sistema operacional invoca quando o programa é executado — outras rotinas podem ser executadas antes da main, por exemplo, para inicializar variáveis globais; no entanto, estes detalhes estão fora do escopo deste livro. Veja mais informações aqui. // hello.cpp #include &lt;iostream&gt; auto main() -&gt; int { std::cout &lt;&lt; &quot;Hello, world!\\n&quot;; } Há várias nuances deste programa que entraremos em detalhes futuramente. No momento, é suficiente saber que esse arquivo, quando compilado e executado, resultará em uma saída com o texto \"Hello, world!\" seguido de quebra de linha. $ g++ -std=c++20 hello.cpp -o hello $ ./hello Hello, world! "],["fluxo.html", "7 Controle de fluxo 7.1 Comandos condicionais 7.2 Comandos de seleção 7.3 Comandos de repetição 7.4 Interrupções 7.5 Tratamento de erros e exceções", " 7 Controle de fluxo Vimos anteriormente que em Assembly, instruções de comparação e de salto podem ser utilizadas em conjunto para controlar o fluxo do programa. Em linguagens de alto nível, utilizamos comandos com semânticas melhor definidas. 7.1 Comandos condicionais 7.2 Comandos de seleção 7.3 Comandos de repetição 7.4 Interrupções 7.5 Tratamento de erros e exceções "],["io.html", "8 Entrada e saída", " 8 Entrada e saída "],["subprogramas.html", "9 Sub-rotinas e recursão 9.1 Recursão", " 9 Sub-rotinas e recursão 9.1 Recursão Muitos problemas computacionais possuem uma propriedade muito interessante: cada instância do problema pose ser subdividida em instâncias menores do mesmo problema. Assim, o algoritmo da solução para o problema é recursivo. Em termos de programação, uma função é dita recursiva se fizer uma chamada a si mesmo. Essa característica é natural em diversas fórmulas matemáticas conhecidas. Consequentemente, diversos problemas podem ser resolvidos de maneira simples quando tratados recursivamente. Por exemplo, definimos o fatorial de um número natural não nulo como \\(n! = n \\cdot (n - 1) \\cdot (n - 2) \\cdot \\dots \\cdot 1\\) e fatorial de zero, \\(0!\\), igual a \\(1\\). Sua formulação recursiva é: \\(n! = 1\\) para \\(n \\leq 1\\); e \\(n! = n \\cdot (n - 1)!\\) para \\(n &gt; 1\\). Traduzindo em termos computacionais, para resolver problemas recursivos, seguimos os seguintes passos: Identificar as instâncias mínimas do problema, ou seja, aquelas que não podem ser subdivididas. Essa instância também é chamada de condição de parada do algoritmo; Para as demais instâncias, reduzir a instância atual em instâncias menores do mesmo problema. Vamos reproduzir esses passos para implementação de um algoritmo recursivo para calcular a soma dos números inteiros entre \\(a\\) e \\(b\\) assumindo que \\(a \\leq b\\). Denotaremos tal soma como \\(s(a, b)\\). Passo 1: A instância mínima desse problema é o caso \\(a = b\\) de modo que o resultado é o próprio valor de \\(a\\) (ou \\(b\\)). Ou seja, \\(s(a, a) = a\\). Passo 2: Para os casos \\(a &lt; b\\), podemos reduzir o problema a partir da seguinte propriedade: \\(s(a, b) = s(a, c) + s(c + 1, b)\\) para todo \\(c\\) tal que \\(a \\leq c &lt; b\\). Deste modo, para o caso específico \\(c = a\\), temos que \\(s(a, b) = s(a, a) + s(a + 1, b)\\). Logo, a implementação deste algoritmo seria: int s(int a, int b) { if (a == b) return a; return s(a, a) + s(a + 1, b); } 9.1.1 Busca binária Dada uma sequência \\(v\\) com \\(n\\) objetos ordenados de maneira crescente, queremos verificar se um determinado objeto \\(k\\) pertence ou não à sequência. É possível escrever um algoritmo recursivo que resolve o problema sem a necessidade de passar por cada elemento \\(x \\in v\\). Para construção da solução, observamos a seguinte propriedade: Se \\(k &gt; v_i\\), sabemos que \\(k \\neq v_j\\) para todo \\(j \\leq i\\); e Se \\(k &lt; v_i\\), que \\(k \\neq v_j\\) para todo \\(j \\geq i\\). Assim, podemos construir uma solução recursiva para o problema. Passo 1: A instância mínima acontece quando \\(n = 0\\) e, consequentemente, \\(k \\not\\in v\\). Passo 2: Podemos subdividir o problema a depender do elemento \\(m = v_{\\lfloor n/2 \\rfloor}\\): Se \\(k = m\\), então \\(k \\in v\\); Se \\(k &lt; m\\), então buscamos \\(k\\) em \\([v_j : 1 &lt; j &lt; \\lfloor n/2 \\rfloor]\\); ou Se \\(k &gt; m\\), então buscamos \\(k\\) em \\([v_j : \\lfloor n/2 \\rfloor &lt; j \\leq n]\\). Exercícios: Com base na formulação recursiva do fatorial e nos passos para construção do algoritmo recursivo, implemente Escreva um algoritmo recursivo para cálculo do \\(i\\)-ésimo elemento da sequência Fibonacci. Escreva um algoritmo recursivo para cálculo do máximo divisor comum (Algoritmo de Euclides). Implemente o algoritmo recursivo de busca binária. Implemente uma função recursiva que calcule a soma dos dígitos decimais de um inteiro positivo. Implemente uma função recursiva para converter número inteiro decimal em sua forma binária. Implemente um algoritmo recursivo que calcule a representação em Gray Code usando \\(N\\) bits de um número \\(0 \\leq k \\leq 2^{N-1}\\). Para todos os algoritmos anteriores, implemente uma versão iterativa. Após ler o capitulo 12, derive qual a complexidade de tempo no pior caso da busca binária em termos do tamanho do vetor. "],["tipos.html", "10 Tipos avançados", " 10 Tipos avançados "],["memoria.html", "11 Memória e ponteiros", " 11 Memória e ponteiros "],["complexity.html", "12 Complexidade computacional 12.1 Importância da análise de complexidade", " 12 Complexidade computacional Neste capítulo, veremos noções básicas de complexidade de algoritmos. Note que não estudaremos formalmente ou profundamente os conceitos. O objetivo é prover intuição sobre os conceitos principais e habilitar o estudante a entender suas implicações na escolha dos algoritmos. 12.1 Importância da análise de complexidade Ao planejarmos a solução para um problema computacional, teremos que escolher uma entre várias possíveis alternativas. Diversos aspectos podem ser considerados para escolha, como facilidade de implementação, familiaridade, ou conveniência. No entanto, o ponto muito importante a ser considerado é eficiência do algoritmo. Podemos definir o conceito de eficiência em termos de dois pontos de vista: de tempo e de memória. Dependendo da situação, as diferenças de eficiência podem: Ser irrelevantes, isto é, ambos os algoritmos possuem eficiência similar para entradas de qualquer tamanho; ou Ser relevantes, isto é, apresentam custos significantemente diferentes, isto é, diferença proporcional ao tamanho da entrada. Muitas vezes, para pequenos problemas, a diferença entre algoritmos torna-se irrelevante. Por isso, o foco deste capítulo é analisar o custo computacional dos algoritmos assintoticamente, ou seja, para entradas muito grandes. Veremos, na próxima parte do livro, como estes conceitos se aplicam também na escolha das estruturas de dados. Exercícios: Escreva um programa que ordene um vetor numérico com tamanho e valores arbitrários. Derive a função de custo de tempo em função do tamanho do vetor de entrada no pior caso. Indique a ordem de complexidade (notação O-grande) de tempo e de espaço do seu algoritmo. Escreva um algoritmo para encontrar o menor valor num vetor. Qual a ordem de complexidade de tempo no pior caso? Escreva um algoritmo para verificar se determinado elemento está num vetor. Qual a ordem de complexidade de tempo no pior caso do seu algoritmo? Considerando que o vetor está ordenado, escreva um algoritmo que tem ordem de complexidade \\(O(\\log n)\\). Escreva um algoritmo recursivo para cálculo do máximo divisor comum (Algoritmo de Euclides). Qual a ordem de complexidade de tempo em função das entradas no pior caso? Dica: procure na literatura a prova que utiliza sequência de Fibonacci. Considerando as funções do tempo de execução abaixo, indique a ordem de complexidade no pior caso para cada uma delas. \\(2 n + 10\\) \\(\\frac{1}{3} n (n + 2)\\) \\(n + \\sqrt n\\) \\(n + 100 n^{0.1}\\) \\(2^n + 3 n + n^{10}\\) \\(n^2 + n \\log n\\) \\(\\log_3 n + \\log_2 n\\) "],["tipos-abstratos-de-dados.html", "13 Tipos abstratos de dados", " 13 Tipos abstratos de dados Um tipo abstrato de dados é uma classe de objetos cujo comportamento lógico é definido por um conjunto de valores e operações (Dale and Walker 1996). Exemplo: conjuntos de números inteiros (veja vídeo). Exercícios: Defina e implemente um TAD para pontos num plano. Defina e implemente um TAD para polígonos gerais. Defina e implemente um TAD para números complexos e implemente. Implemente o TAD “Conjunto de Números Inteiros” com as seguintes operações: criar conjunto vazio, criar conjunto a partir de um intervalo finito, união, intersecção, diferença, e verificar se contém um determinado número. References "],["sequências.html", "14 Sequências 14.1 Listas 14.2 Iterador 14.3 Colônia", " 14 Sequências Há dois principais tipos de sequências: lista e colônia1. Listas são estruturas de dados cujos elementos podem ser acessados sequencialmente preservando a ordem destes. Colônias, por sua vez, sacrificam a ordem dos elementos para garantir outras propriedades desejadas. 14.1 Listas 14.1.1 Modelo abstrato e operações em listas Para definir o nosso modelo abstrato de lista, vamos começar pelas operações desejáveis. Operações comuns em listas. Operação Parâmetros Descrição Criar Capacidade Cria uma lista com capacidade especificada (potencialmente ilimitada2). Copiar Cria uma cópia da lista. Esvaziar Esvazia a lista. Acessar Posição Acessa um elemento da lista dada uma posição. Inserir Elemento, Posição Insere um elemento numa posição específica da lista. Remover Posição Remove o elemento numa posição específica da lista. Concatenar Lista Concatena outra lista no fim da lista. Separar Posição Separa a lista em duas a partir duma determinada posição. Além dessas operações, há outras mais triviais, como consultar o tamanho, consultar a capacidade, verificar se está cheia, e verificar se está vazia. Em C++17, podemos definir uma interface3 básica: template &lt;typename T&gt; class list { public: explicit list(std::size_t capacity); ~list() noexcept; list(const list&amp;); list(list&amp;&amp;) noexcept; auto operator=(const list&amp;) -&gt; list&amp;; auto operator=(list&amp;&amp;) noexcept -&gt; list&amp;; auto empty() -&gt; void; auto size() const -&gt; std::size_t; auto capacity() const -&gt; std::size_t; auto is_empty() const -&gt; bool; auto is_full() const -&gt; bool; auto at(std::size_t) -&gt; T&amp;; auto front() -&gt; T&amp;; auto back() -&gt; T&amp;; auto insert(std::size_t, T) -&gt; void; auto remove(std::size_t) -&gt; void; auto concat(list&lt;T&gt;) -&gt; void; auto split(std::size_t) -&gt; list&lt;T&gt;; }; Uma vez que levantamos as operações desejáveis da lista, veremos diferentes estruturas de dados que contemplam essa finalidade. Veremos também que cada uma delas apresentará diferentes vantagens e desvantagens em termos de complexidade de tempo. Além disso, dependendo da estrutura que escolhermos, mudaremos alguns detalhes da nossa interface para melhor adequá-la ao contexto. 14.1.2 Implementações de listas Nas implementações, não vamos usar os containers da STL (std::vector, std::list, etc) por motivos didáticos. 14.1.2.1 Lista contígua estática template &lt;typename T, std::size_t N&gt; class list { public: list() = default; // ... private: using storage_type = std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt;; std::array&lt;storage_type, N&gt; values_; std::size_t size_ = 0u; }; Não precisamos implementar o construtor. Exercício: Por que o construtor padrão (gerado pelo compilador) é suficiente neste caso? Limpando a lista: template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::empty() { if constexpr (!std::is_trivially_destructible_v&lt;T&gt;) for (std::size_t i = 0; i &lt; size_; ++i) std::destroy_at(std::address_of(values_[i])); size_ = 0; } Com esta operação, a implementação do destrutor torna-se bastante simples: template &lt;typename T, std::size_t N&gt; list&lt;T, N&gt;::~list() noexcept { empty(); } Checando as margens: template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::is_empty() const -&gt; bool { return size_ == 0; } template &lt;typename T, std::size_t N&gt; auto list&lt;T, N&gt;::is_full() const -&gt; bool { return size_ == N; } Os construtores de cópia e movimentação são triviais: template &lt;typename T, std::size_t N&gt; list&lt;T, N&gt;::list(const list&amp; source) { for (std::size_t i = 0; i &lt; source.size_; ++i) ::new (std::address_of(values_[i])) T(source.values_[i]); size_ = source.size_; } template &lt;typename T, std::size_t N&gt; list&lt;T, N&gt;::list(list&amp;&amp; source) noexcept { for (std::size_t i = 0; i &lt; source.size_; ++i) ::new (std::address_of(values_[i])) T(std::move(source.values_[i])); size_ = std::exchange(source.size_, 0u); } Exercícios: Implementar as operações de atribuição (cópia e movimentação) eficientemente. Implementar versão destas operações (construtores e atribuições) garantias de exceção fortes nestas operações (sem utilizar funções prontas da biblioteca padrão). 14.1.3 Contíguo dinâmico template &lt;typename T&gt; class list { public: // ... private: using storage_type = std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt;; std::unique_ptr&lt;storage_type[]&gt; values_; std::size_t capacity_; std::size_t size_ = 0u; }; 14.1.3.1 Simplesmente encadeada 14.1.3.2 Duplamente encadeada 14.1.3.3 Possíveis aprimoramentos 14.2 Iterador 14.3 Colônia Em inglês, colony.↩︎ Ilimitada conceitualmente; toda estrutura digital possui limitações de armazenamento.↩︎ Não no sentido de orientação à objeto, mas em um sentido mais amplo.↩︎ "],["adaptadores.html", "15 Adaptadores", " 15 Adaptadores Pilha (LIFO), fila (FIFO), lista de prioridade "],["árvores.html", "16 Árvores 16.1 Árvores binárias", " 16 Árvores 16.1 Árvores binárias template &lt;typename T&gt; struct btree; template &lt;typename T&gt; using btree_ptr = std::shared_ptr&lt;btree&lt;T&gt;&gt;; template &lt;typename T&gt; struct btree { T value; btree_ptr left_child = nullptr; btree_ptr right_child = nullptr; }; enum class ordering { in_order, pre_order, post_order, }; template &lt;typename T&gt; using visitor = std::function&lt;bool(const T&amp;)&gt;; template &lt;typename T&gt; void dfs(btree_ptr&lt;T&gt; root, ordering order, const visitor&amp; visit) { if (root == nullptr) return; switch (order) { case in_order: dfs(root-&gt;left_child, order, visit); if (!visit(root-&gt;value)) return; dfs(root-&gt;right_child, order, visit); break; case pre_order: dfs(root-&gt;left_child, order, visit); dfs(root-&gt;right_child, order, visit); if (!visit(root-&gt;value)) return; break; case post_order: if (!visit(root-&gt;value)) return; dfs(root-&gt;left_child, order, visit); dfs(root-&gt;right_child, order, visit); break; } } template &lt;typename T&gt; void bfs(btree_ptr&lt;T&gt; root, const visitor&amp; visit) { std::queue&lt;btree_ptr&gt; queue; queue.push(root); while (!queue.empty()) { if (queue.front() == nullptr) { queue.pop(); continue; } if (!visit(queue.front()-&gt;value)) return; queue.push(queue.front()-&gt;left_child); queue.push(queue.front()-&gt;right_child); queue.pop(); } } "],["estruturas-associativas.html", "17 Estruturas associativas 17.1 Árvores Binárias de Busca", " 17 Estruturas associativas Conjuntos e mapas ordenados (árvores) e não ordenados (hashing) 17.1 Árvores Binárias de Busca template &lt;typename K, typename V&gt; class bstree { struct node_data; using node = std::shared_ptr&lt;node_data&gt;; struct node_data { K key; V value; node left_child = nullptr; node right_child = nullptr; }; public: void insert(const K&amp; key, const V&amp; value) { root = insert_recursive(root, key, value); } void remove(const K&amp; key) { root = remove_recursive(root, key); } auto search(const K&amp; key) const -&gt; std::optional&lt;V&gt; { const auto pos = search_recursive(root, key); if (pos != nullptr) return pos-&gt;value; return std::nullopt; } private: node root = nullptr; static auto insert_recursive( node root, const K&amp; key, const V&amp; value) -&gt; node { if (root == nullptr) return node(new node_data{key, value}); if (key &lt; root-&gt;key) root-&gt;left_child = insert_recursive(root-&gt;left_child, key, value); else if (key &gt; root-&gt;key) root-&gt;right_child = insert_recursive(root-&gt;right_child, key, value); return root; } static auto remove_recursive(node root, const K&amp; key) -&gt; node { if (root == nullptr) return nullptr; if (key &lt; root-&gt;key) { root-&gt;left_child = remove_recursive(root-&gt;left_child, key); return root; } if (key &gt; root-&gt;key) { root-&gt;right_child = remove_recursive(root-&gt;right_child, key); return root; } if (root-&gt;left_child == nullptr &amp;&amp; root-&gt;right_child == nullptr) return nullptr; if (root-&gt;left_child != nullptr &amp;&amp; root-&gt;right_child != nullptr) { const auto child = left_most(root-&gt;right_child); std::swap(root-&gt;key, child-&gt;key); root-&gt;right_child = remove_recursive(root-&gt;right_child, child-&gt;key); return root; } return root-&gt;left_child != nullptr ? root-&gt;left_child : root-&gt;right_child; } static auto left_most(node root) -&gt; node { return root-&gt;left_child == nullptr ? root : left_most(root-&gt;left_child); } static auto search_recursive(node root, K key) -&gt; node { if (root == nullptr) return nullptr; if (key &lt; root-&gt;key) return search_recursive(root-&gt;left_child, key); if (key &gt; root-&gt;key) return search_recursive(root-&gt;right_child, key); return root; } }; "],["particionamento.html", "18 Particionamento", " 18 Particionamento "],["ordenação.html", "19 Ordenação 19.1 Bubble sort 19.2 Shaker sort 19.3 Selection sort 19.4 Insertion sort 19.5 Shell sort 19.6 Quick sort 19.7 Merge sort", " 19 Ordenação OBS: questões de estabilidade na ordenação são omitidas neste livro. 19.1 Bubble sort template &lt;std::forward_iterator It&gt; void bubblesort(It begin, It end) { for (; begin != end; --end) for (auto left = begin, right = std::next(left); right != end; left = right++) if (*left &gt; *right) std::iter_swap(left, right); } Exercícios: Altere o código da função bubblesort para interromper as passagens quando não houver mais trocas. Compare o tempo de execução das duas versões da função bubblesort para vetores muito grandes. 19.2 Shaker sort template &lt;std::bidirectional_iterator It&gt; void shakersort(It begin, It end) { while (true) { for (auto left = begin, right = std::next(left); right != end; left = right++) if (*left &gt; *right) std::iter_swap(left, right); if (begin == --end) return; for (auto right = std::prev(end), left = std::prev(right); right != begin; right = left--) if (*left &gt; *right) std::iter_swap(left, right); if (++begin == end) return; } } Exercícios: Altere o código da função shakersort para interromper as passagens quando não houver mais trocas. Compare o tempo de execução das duas versões da função shakersort para vetores muito grandes. Qual algoritmo se beneficia mais desta interrupção: bubble sort ou shaker sort? 19.3 Selection sort template &lt;std::forward_iterator It&gt; void selectionsort(It begin, It end) { for (auto it = begin; it != end; ++it) std::iter_swap(it, std::min_element(it, end)); } 19.4 Insertion sort template &lt;std::bidirectional_iterator It&gt; void insertionsort(It begin, It end) { for (auto it = std::next(begin); it != end; ++it) for (auto right = it, left = std::prev(right); right != begin &amp;&amp; *left &gt; *right; right = left--) std::iter_swap(left, right); } 19.5 Shell sort template &lt;std::integral T&gt; auto knuth_seq_last(T length) { T h = 1; while (h &lt; length) h = 3 * h + 1; return h / 3; } template &lt;std::random_access_iterator It&gt; void shellsort(It begin, It end) { const auto length = std::distance(begin, end); for (auto h = knuth_seq_last(length); h &gt; 0; h = h / 3) for (auto it = std::next(begin, h); it != end; ++it) for (auto right = it, left = std::prev(right, h); std::distance(begin, right) &gt;= h &amp;&amp; *left &gt; *right; right = std::exchange(left, std::prev(left, h))) std::iter_swap(left, right); } Exercícios: Ignorando questões de desempenho, a função shellsort poderia ser implementada para iteradores bidirecionais (e sem acesso aleatório). Justifique a necessidade de acesso aleatório para manter as vantagens do shell sort em comparação com o insertion sort. 19.6 Quick sort template &lt;std::bidirectional_iterator It&gt; void quicksort(It begin, It end) { if (begin == end) return; auto left = begin; auto right = std::prev(end); const auto pivot_value = *left; while (true) { while (left != right &amp;&amp; *right &gt;= pivot_value) --right; if (left == right) break; std::iter_swap(left++, right); while (left != right &amp;&amp; *left &lt;= pivot_value) ++left; if (left == right) break; std::iter_swap(left, right--); } quicksort(begin, left); quicksort(std::next(left), end); } 19.7 Merge sort template &lt;std::forward_iterator It&gt; void merge(It begin, It mid, It end) { std::vector&lt;std::iter_value_t&lt;It&gt;&gt; tmp; auto it1 = begin, it2 = mid; while (it1 != mid &amp;&amp; it2 != end) tmp.push_back(std::move(*it1 &lt; *it2 ? *it1++ : *it2++)); std::move(it1, mid, back_inserter(tmp)); std::move(it2, end, back_inserter(tmp)); std::move(tmp.begin(), tmp.end(), begin); } template &lt;std::random_access_iterator It&gt; void mergesort(It begin, It end) { const auto length = std::distance(begin, end); if (length &lt; 2) return; const auto mid = std::next(begin, length / 2); merge_sort(begin, mid); merge_sort(mid, end); merge(begin, mid, end); } Exercícios: Discuta as desvantagens de permitir que a função mergesort aceite iteradores unidirecionais ao invés de requerer acesso aleatório. Implemente o algoritmo merge sort evitando as inúmeras alocações de memória temporária. "],["busca.html", "20 Busca", " 20 Busca "],["operações-de-conjuntos-em-listas-ordenadas.html", "21 Operações de conjuntos em listas ordenadas", " 21 Operações de conjuntos em listas ordenadas "],["operações-de-heap.html", "22 Operações de heap", " 22 Operações de heap "],["operações-numéricas.html", "23 Operações numéricas", " 23 Operações numéricas Transformação (apply, map), redução, produto interno (zip). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
