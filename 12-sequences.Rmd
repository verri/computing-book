# (PART) Estruturas de dados {-}

# Listas

Listas são estruturas de dados cujos elementos podem ser acessados
sequencialmente.

## Modelo abstrato e operações em listas

Table: Operações complexas em listas

Operação      Parâmetros          Descrição
--------      ----------          ---------
Criar         Capacidade          Cria uma lista com capacidade especificada (potencialmente ilimitada^[Ilimitada conceitualmente; toda estrutura digital possui limitações de armazenamento.]).
Copiar                            Cria uma cópia da lista.
Esvaziar                          Esvazia a lista.
Acessar       Posição             Acessa um elemento da lista dada uma posição.
Inserir       Elemento, Posição   Insere um elemento numa posição específica da lista.
Remover       Posição             Remove o elemento numa posição específica da lista.
Concatenar    Lista               Concatena outra lista no fim da lista.
Separar       Posição             Separa a lista em duas a partir duma determinada posição.

Além dessas operações, há outras mais triviais, como consultar o tamanho,
consultar a capacidade, verificar se está cheia, e verificar se está vazia.

Em C++20, podemos definir uma interface^[Não no sentido de orientação à objeto,
mas em um sentido mais amplo.] básica:
```cpp
template <typename T> class list {
public:
  explicit list(std::size_t capacity);
  ~list();

  list(const list&);
  list(list&&);

  auto operator=(const list&) -> list&;
  auto operator=(list&&) -> list&;

  auto empty() -> void;

  auto size() const -> std::size_t;
  auto capacity() const -> std::size_t;

  auto is_empty() const -> bool;
  auto is_full() const -> bool;

  auto at(std::size_t) -> T&;
  auto front() -> T&;
  auto back() -> T&;

  auto insert(std::size_t, T) -> void;
  auto remove(std::size_t) -> void;

  auto concat(list<T>) -> void;
  auto split(std::size_t) -> list<T>;
};
```

Veremos que dependendo da versão, podemos mudar uns detalhes da nossa interface
para melhor adequá-la ao contexto.

## Implementações de listas

Nas implementações, não vamos usar os containers da STL (`std::vector`,
`std::list`, etc) por motivos didáticos.

### Contíguo estático

```cpp
template <typename T, std::size_t N> class list {
public:
  list() = default;
  // ...
private:
  using storage_type = std::aligned_storage_t<sizeof(T), alignof(T)>;
  std::array<storage_type, N> values_;
  std::size_t size_ = 0u;
};
```

Não precisamos de construtor.

Não precisamos de um destrutor.

Limpando a lista:
```cpp
template <typename T, std::size_t N>
auto list<T, N>::empty() {
  if constexpr (!std::is_trivially_destructible_v<T>)
    std::destroy(begin(values), begin(values) + size_);
  size_ = 0;
}
```

Checando as margens:
```cpp
template <typename T, std::size_t N>
auto list<T, N>::is_empty() const -> bool {
  return size_ == 0;
}

template <typename T, std::size_t N>
auto list<T, N>::is_full() const -> bool {
  return size_ == N;
}
```

### Contíguo dinâmico

```cpp
template <typename T> class list {
public:
  // ...
private:
  using storage_type = std::aligned_storage_t<sizeof(T), alignof(T)>;
  std::unique_ptr<storage_type[]> values_;
  std::size_t capacity_;
  std::size_t size_ = 0u;
};
```

### Simplesmente encadeada

### Duplamente encadeada

### Outros

## Iteradores
